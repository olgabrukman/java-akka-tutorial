

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Configuration &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3.15',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="General" href="index.html" />
    <link rel="next" title="Actors" href="../java/index-actors.html" />
    <link rel="prev" title="Message Delivery Reliability" href="message-delivery-reliability.html" />

  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://www.typesafe.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Configuration</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="../java/index-actors.html">Actors</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="message-delivery-reliability.html">Message Delivery Reliability</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.3.15
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="configuration">
<span id="id1"></span><h1>Configuration</h1>
<p>You can start using Akka without defining any configuration, since sensible default values
are provided. Later on you might need to amend the settings to change the default behavior
or adapt for specific runtime environments. Typical examples of settings that you
might amend:</p>
<ul class="simple">
<li>log level and logger backend</li>
<li>enable remoting</li>
<li>message serializers</li>
<li>definition of routers</li>
<li>tuning of dispatchers</li>
</ul>
<p>Akka uses the <a class="reference external" href="https://github.com/typesafehub/config">Typesafe Config Library</a>, which might also be a good choice
for the configuration of your own application or library built with or without
Akka. This library is implemented in Java with no external dependencies; you
should have a look at its documentation (in particular about <a class="reference external" href="http://typesafehub.github.io/config/v1.2.0/com/typesafe/config/ConfigFactory.html">ConfigFactory</a>),
which is only summarized in the following.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you use Akka from the Scala REPL from the 2.9.x series,
and you do not provide your own ClassLoader to the ActorSystem,
start the REPL with &quot;-Yrepl-sync&quot; to work around a deficiency in
the REPLs provided Context ClassLoader.</p>
</div>
<div class="section" id="where-configuration-is-read-from">
<h2>Where configuration is read from</h2>
<p>All configuration for Akka is held within instances of <code class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></code>, or
put differently, as viewed from the outside, <code class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></code> is the only
consumer of configuration information. While constructing an actor system, you
can either pass in a <code class="xref py py-class docutils literal"><span class="pre">Config</span></code> object or not, where the second case is
equivalent to passing <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> (with the right class loader).
This means roughly that the default is to parse all <code class="docutils literal"><span class="pre">application.conf</span></code>,
<code class="docutils literal"><span class="pre">application.json</span></code> and <code class="docutils literal"><span class="pre">application.properties</span></code> found at the root of the
class path—please refer to the aforementioned documentation for details. The
actor system then merges in all <code class="docutils literal"><span class="pre">reference.conf</span></code> resources found at the root
of the class path to form the fallback configuration, i.e. it internally uses</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">appConfig</span><span class="o">.</span><span class="n">withFallback</span><span class="o">(</span><span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">defaultReference</span><span class="o">(</span><span class="n">classLoader</span><span class="o">))</span>
</pre></div>
</div>
<p>The philosophy is that code never contains default values, but instead relies
upon their presence in the <code class="docutils literal"><span class="pre">reference.conf</span></code> supplied with the library in
question.</p>
<p>Highest precedence is given to overrides given as system properties, see <a class="reference external" href="https://github.com/typesafehub/config/blob/master/HOCON.md">the
HOCON specification</a> (near the
bottom). Also noteworthy is that the application configuration—which defaults
to <code class="docutils literal"><span class="pre">application</span></code>—may be overridden using the <code class="docutils literal"><span class="pre">config.resource</span></code> property
(there are more, please refer to the <a class="reference external" href="https://github.com/typesafehub/config/blob/master/README.md">Config docs</a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are writing an Akka application, keep you configuration in
<code class="docutils literal"><span class="pre">application.conf</span></code> at the root of the class path. If you are writing an
Akka-based library, keep its configuration in <code class="docutils literal"><span class="pre">reference.conf</span></code> at the root
of the JAR file.</p>
</div>
</div>
<div class="section" id="when-using-jarjar-onejar-assembly-or-any-jar-bundler">
<h2>When using JarJar, OneJar, Assembly or any jar-bundler</h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Akka's configuration approach relies heavily on the notion of every
module/jar having its own reference.conf file, all of these will be
discovered by the configuration and loaded. Unfortunately this also means
that if you put/merge multiple jars into the same jar, you need to merge all the
reference.confs as well. Otherwise all defaults will be lost and Akka will not function.</p>
</div>
<p>If you are using Maven to package your application, you can also make use of
the <a class="reference external" href="http://maven.apache.org/plugins/maven-shade-plugin">Apache Maven Shade Plugin</a> support for <a class="reference external" href="http://maven.apache.org/plugins/maven-shade-plugin/examples/resource-transformers.html#AppendingTransformer">Resource
Transformers</a>
to merge all the reference.confs on the build classpath into one.</p>
<p>The plugin configuration might look like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">plugin</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">maven</span><span class="o">.</span><span class="n">plugins</span><span class="o">&lt;/</span><span class="n">groupId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">maven</span><span class="o">-</span><span class="n">shade</span><span class="o">-</span><span class="n">plugin</span><span class="o">&lt;/</span><span class="n">artifactId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="mf">1.5</span><span class="o">&lt;/</span><span class="n">version</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">executions</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">execution</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">phase</span><span class="o">&gt;</span><span class="n">package</span><span class="o">&lt;/</span><span class="n">phase</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">goals</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">goal</span><span class="o">&gt;</span><span class="n">shade</span><span class="o">&lt;/</span><span class="n">goal</span><span class="o">&gt;</span>
   <span class="o">&lt;/</span><span class="n">goals</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">configuration</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">shadedArtifactAttached</span><span class="o">&gt;</span><span class="kc">true</span><span class="o">&lt;/</span><span class="n">shadedArtifactAttached</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">shadedClassifierName</span><span class="o">&gt;</span><span class="n">allinone</span><span class="o">&lt;/</span><span class="n">shadedClassifierName</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">artifactSet</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">includes</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">include</span><span class="o">&gt;*:*&lt;/</span><span class="n">include</span><span class="o">&gt;</span>
     <span class="o">&lt;/</span><span class="n">includes</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">artifactSet</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">transformers</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">transformer</span>
       <span class="n">implementation</span><span class="o">=</span><span class="s">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span><span class="o">&gt;</span>
       <span class="o">&lt;</span><span class="n">resource</span><span class="o">&gt;</span><span class="n">reference</span><span class="o">.</span><span class="n">conf</span><span class="o">&lt;/</span><span class="n">resource</span><span class="o">&gt;</span>
      <span class="o">&lt;/</span><span class="n">transformer</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">transformer</span>
       <span class="n">implementation</span><span class="o">=</span><span class="s">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span><span class="o">&gt;</span>
       <span class="o">&lt;</span><span class="n">manifestEntries</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nc">Main</span><span class="o">-</span><span class="nc">Class</span><span class="o">&gt;</span><span class="n">akka</span><span class="o">.</span><span class="nc">Main</span><span class="o">&lt;/</span><span class="nc">Main</span><span class="o">-</span><span class="nc">Class</span><span class="o">&gt;</span>
       <span class="o">&lt;/</span><span class="n">manifestEntries</span><span class="o">&gt;</span>
      <span class="o">&lt;/</span><span class="n">transformer</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">transformers</span><span class="o">&gt;</span>
   <span class="o">&lt;/</span><span class="n">configuration</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">execution</span><span class="o">&gt;</span>
 <span class="o">&lt;/</span><span class="n">executions</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">plugin</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-application-conf">
<h2>Custom application.conf</h2>
<p>A custom <code class="docutils literal"><span class="pre">application.conf</span></code> might look like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span># In this file you can override any option defined in the reference files.
# Copy in parts of the reference files and modify as you please.

akka {

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = [&quot;akka.event.slf4j.Slf4jLogger&quot;]

  # Log level used by the configured loggers (see &quot;loggers&quot;) as soon
  # as they have been started; before that, see &quot;stdout-loglevel&quot;
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = &quot;DEBUG&quot;

  # Log level for the very basic logger activated during ActorSystem startup.
  # This logger prints the log messages to stdout (System.out).
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = &quot;DEBUG&quot;

  actor {
    provider = &quot;akka.cluster.ClusterActorRefProvider&quot;

    default-dispatcher {
      # Throughput for default Dispatcher, set to 1 for as fair as possible
      throughput = 10
    }
  }

  remote {
    # The port clients should connect to. Default is 2552.
    netty.tcp.port = 4711
  }
}
</pre></div>
</div>
</div>
<div class="section" id="including-files">
<h2>Including files</h2>
<p>Sometimes it can be useful to include another configuration file, for example if you have one <code class="docutils literal"><span class="pre">application.conf</span></code> with all
environment independent settings and then override some settings for specific environments.</p>
<p>Specifying system property with <code class="docutils literal"><span class="pre">-Dconfig.resource=/dev.conf</span></code> will load the <code class="docutils literal"><span class="pre">dev.conf</span></code> file, which includes the <code class="docutils literal"><span class="pre">application.conf</span></code></p>
<p>dev.conf:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">include</span> <span class="s">&quot;application&quot;</span>

<span class="n">akka</span> <span class="o">{</span>
  <span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;DEBUG&quot;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>More advanced include and substitution mechanisms are explained in the <a class="reference external" href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a>
specification.</p>
</div>
<div class="section" id="logging-of-configuration">
<span id="dakka-log-config-on-start"></span><h2>Logging of Configuration</h2>
<p>If the system or config property <code class="docutils literal"><span class="pre">akka.log-config-on-start</span></code> is set to <code class="docutils literal"><span class="pre">on</span></code>, then the
complete configuration at INFO level when the actor system is started. This is useful
when you are uncertain of what configuration is used.</p>
<p>If in doubt, you can also easily and nicely inspect configuration objects
before or after using them to construct an actor system:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span>Welcome to Scala version 2.10.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_27).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import com.typesafe.config._
import com.typesafe.config._

scala&gt; ConfigFactory.parseString(&quot;a.b=12&quot;)
res0: com.typesafe.config.Config = Config(SimpleConfigObject({&quot;a&quot; : {&quot;b&quot; : 12}}))

scala&gt; res0.root.render
res1: java.lang.String =
{
    # String: 1
    &quot;a&quot; : {
        # String: 1
        &quot;b&quot; : 12
    }
}
</pre></div>
</div>
<p>The comments preceding every item give detailed information about the origin of
the setting (file &amp; line number) plus possible comments which were present,
e.g. in the reference configuration. The settings as merged with the reference
and parsed by the actor system can be displayed like this:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">final</span> <span class="n">ActorSystem</span> <span class="n">system</span> <span class="o">=</span> <span class="n">ActorSystem</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">system</span><span class="o">.</span><span class="na">settings</span><span class="o">());</span>
<span class="c1">// this is a shortcut for system.settings().config().root().render()</span>
</pre></div>
</div>
</div>
<div class="section" id="a-word-about-classloaders">
<h2>A Word About ClassLoaders</h2>
<p>In several places of the configuration file it is possible to specify the
fully-qualified class name of something to be instantiated by Akka. This is
done using Java reflection, which in turn uses a <code class="xref py py-class docutils literal"><span class="pre">ClassLoader</span></code>. Getting
the right one in challenging environments like application containers or OSGi
bundles is not always trivial, the current approach of Akka is that each
<code class="xref py py-class docutils literal"><span class="pre">ActorSystem</span></code> implementation stores the current thread’s context class
loader (if available, otherwise just its own loader as in
<code class="docutils literal"><span class="pre">this.getClass.getClassLoader</span></code>) and uses that for all reflective accesses.
This implies that putting Akka on the boot class path will yield
<code class="xref py py-class docutils literal"><span class="pre">NullPointerException</span></code> from strange places: this is simply not
supported.</p>
</div>
<div class="section" id="application-specific-settings">
<h2>Application specific settings</h2>
<p>The configuration can also be used for application specific settings.
A good practice is to place those settings in an Extension, as described in:</p>
<blockquote>
<div><ul class="simple">
<li>Scala API: <a class="reference internal" href="../scala/extending-akka.html#extending-akka-scala-settings"><span>Application specific settings</span></a></li>
<li>Java API: <a class="reference internal" href="../java/extending-akka.html#extending-akka-java-settings"><span>Application specific settings</span></a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="configuring-multiple-actorsystem">
<h2>Configuring multiple ActorSystem</h2>
<p>If you have more than one <code class="docutils literal"><span class="pre">ActorSystem</span></code> (or you're writing a
library and have an <code class="docutils literal"><span class="pre">ActorSystem</span></code> that may be separate from the
application's) you may want to separate the configuration for each
system.</p>
<p>Given that <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> merges all resources with matching name
from the whole class path, it is easiest to utilize that functionality and
differentiate actor systems within the hierarchy of the configuration:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">myapp1</span> <span class="o">{</span>
  <span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;WARNING&quot;</span>
  <span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="mi">43</span>
<span class="o">}</span>
<span class="n">myapp2</span> <span class="o">{</span>
  <span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="k">=</span> <span class="s">&quot;ERROR&quot;</span>
  <span class="n">app2</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="s">&quot;appname&quot;</span>
<span class="o">}</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="mi">42</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
</pre></div>
</div>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">config</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">()</span>
<span class="k">val</span> <span class="n">app1</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MyApp1&quot;</span><span class="o">,</span> <span class="n">config</span><span class="o">.</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;myapp1&quot;</span><span class="o">).</span><span class="n">withFallback</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
<span class="k">val</span> <span class="n">app2</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MyApp2&quot;</span><span class="o">,</span>
  <span class="n">config</span><span class="o">.</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;myapp2&quot;</span><span class="o">).</span><span class="n">withOnlyPath</span><span class="o">(</span><span class="s">&quot;akka&quot;</span><span class="o">).</span><span class="n">withFallback</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
</pre></div>
</div>
<p>These two samples demonstrate different variations of the “lift-a-subtree”
trick: in the first case, the configuration accessible from within the actor
system is this</p>
<div class="highlight-ruby"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="s2">&quot;WARNING&quot;</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="mi">43</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="sr">//</span> <span class="n">plus</span> <span class="n">myapp1</span> <span class="ow">and</span> <span class="n">myapp2</span> <span class="n">subtrees</span>
</pre></div>
</div>
<p>while in the second one, only the “akka” subtree is lifted, with the following
result</p>
<div class="highlight-ruby"><div class="highlight"><pre><span></span><span class="n">akka</span><span class="o">.</span><span class="n">loglevel</span> <span class="o">=</span> <span class="s2">&quot;ERROR&quot;</span>
<span class="n">my</span><span class="o">.</span><span class="n">own</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">my</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">setting</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>
<span class="sr">//</span> <span class="n">plus</span> <span class="n">myapp1</span> <span class="ow">and</span> <span class="n">myapp2</span> <span class="n">subtrees</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The configuration library is really powerful, explaining all features exceeds
the scope affordable here. In particular not covered are how to include other
configuration files within other files (see a small example at <a class="reference internal" href="#including-files">Including
files</a>) and copying parts of the configuration tree by way of path
substitutions.</p>
</div>
<p>You may also specify and parse the configuration programmatically in other ways when instantiating
the <code class="docutils literal"><span class="pre">ActorSystem</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
    <span class="k">val</span> <span class="n">customConf</span> <span class="k">=</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">      akka.actor.deployment {</span>
<span class="s">        /my-service {</span>
<span class="s">          router = round-robin-pool</span>
<span class="s">          nr-of-instances = 3</span>
<span class="s">        }</span>
<span class="s">      }</span>
<span class="s">      &quot;&quot;&quot;</span><span class="o">)</span>
    <span class="c1">// ConfigFactory.load sandwiches customConfig between default reference</span>
    <span class="c1">// config and default overrides, and then resolves it.</span>
    <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;MySystem&quot;</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">customConf</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-configuration-from-a-custom-location">
<h2>Reading configuration from a custom location</h2>
<p>You can replace or supplement <code class="docutils literal"><span class="pre">application.conf</span></code> either in code
or using system properties.</p>
<p>If you're using <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> (which Akka does by
default) you can replace <code class="docutils literal"><span class="pre">application.conf</span></code> by defining
<code class="docutils literal"><span class="pre">-Dconfig.resource=whatever</span></code>, <code class="docutils literal"><span class="pre">-Dconfig.file=whatever</span></code>, or
<code class="docutils literal"><span class="pre">-Dconfig.url=whatever</span></code>.</p>
<p>From inside your replacement file specified with
<code class="docutils literal"><span class="pre">-Dconfig.resource</span></code> and friends, you can <code class="docutils literal"><span class="pre">include</span>
<span class="pre">&quot;application&quot;</span></code> if you still want to use
<code class="docutils literal"><span class="pre">application.{conf,json,properties}</span></code> as well.  Settings
specified before <code class="docutils literal"><span class="pre">include</span> <span class="pre">&quot;application&quot;</span></code> would be overridden by
the included file, while those after would override the included
file.</p>
<p>In code, there are many customization options.</p>
<p>There are several overloads of <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code>; these
allow you to specify something to be sandwiched between system
properties (which override) and the defaults (from
<code class="docutils literal"><span class="pre">reference.conf</span></code>), replacing the usual
<code class="docutils literal"><span class="pre">application.{conf,json,properties}</span></code> and replacing
<code class="docutils literal"><span class="pre">-Dconfig.file</span></code> and friends.</p>
<p>The simplest variant of <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> takes a resource
basename (instead of <code class="docutils literal"><span class="pre">application</span></code>); <code class="docutils literal"><span class="pre">myname.conf</span></code>,
<code class="docutils literal"><span class="pre">myname.json</span></code>, and <code class="docutils literal"><span class="pre">myname.properties</span></code> would then be used
instead of <code class="docutils literal"><span class="pre">application.{conf,json,properties}</span></code>.</p>
<p>The most flexible variant takes a <code class="docutils literal"><span class="pre">Config</span></code> object, which
you can load using any method in <code class="docutils literal"><span class="pre">ConfigFactory</span></code>.  For example
you could put a config string in code using
<code class="docutils literal"><span class="pre">ConfigFactory.parseString()</span></code> or you could make a map and
<code class="docutils literal"><span class="pre">ConfigFactory.parseMap()</span></code>, or you could load a file.</p>
<p>You can also combine your custom config with the usual config,
that might look like:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// make a Config with just your special setting</span>
<span class="nc">Config</span> <span class="n">myConfig</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span><span class="s">&quot;something=somethingElse&quot;</span><span class="o">);</span>
<span class="c1">// load the normal config stack (system props,</span>
<span class="c1">// then application.conf, then reference.conf)</span>
<span class="nc">Config</span> <span class="n">regularConfig</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">();</span>
<span class="c1">// override regular stack with myConfig</span>
<span class="nc">Config</span> <span class="n">combined</span> <span class="k">=</span>
  <span class="n">myConfig</span><span class="o">.</span><span class="n">withFallback</span><span class="o">(</span><span class="n">regularConfig</span><span class="o">);</span>
<span class="c1">// put the result in between the overrides</span>
<span class="c1">// (system props) and defaults again</span>
<span class="nc">Config</span> <span class="n">complete</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">combined</span><span class="o">);</span>
<span class="c1">// create ActorSystem</span>
<span class="nc">ActorSystem</span> <span class="n">system</span> <span class="k">=</span>
  <span class="nc">ActorSystem</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="s">&quot;myname&quot;</span><span class="o">,</span> <span class="n">complete</span><span class="o">);</span>
</pre></div>
</div>
<p>When working with <code class="docutils literal"><span class="pre">Config</span></code> objects, keep in mind that there are
three &quot;layers&quot; in the cake:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ConfigFactory.defaultOverrides()</span></code> (system properties)</li>
<li>the app's settings</li>
<li><code class="docutils literal"><span class="pre">ConfigFactory.defaultReference()</span></code> (reference.conf)</li>
</ul>
</div></blockquote>
<p>The normal goal is to customize the middle layer while leaving the
other two alone.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> loads the whole stack</li>
<li>the overloads of <code class="docutils literal"><span class="pre">ConfigFactory.load()</span></code> let you specify a
different middle layer</li>
<li>the <code class="docutils literal"><span class="pre">ConfigFactory.parse()</span></code> variations load single files or resources</li>
</ul>
</div></blockquote>
<p>To stack two layers, use <code class="docutils literal"><span class="pre">override.withFallback(fallback)</span></code>; try
to keep system props (<code class="docutils literal"><span class="pre">defaultOverrides()</span></code>) on top and
<code class="docutils literal"><span class="pre">reference.conf</span></code> (<code class="docutils literal"><span class="pre">defaultReference()</span></code>) on the bottom.</p>
<p>Do keep in mind, you can often just add another <code class="docutils literal"><span class="pre">include</span></code>
statement in <code class="docutils literal"><span class="pre">application.conf</span></code> rather than writing code.
Includes at the top of <code class="docutils literal"><span class="pre">application.conf</span></code> will be overridden by
the rest of <code class="docutils literal"><span class="pre">application.conf</span></code>, while those at the bottom will
override the earlier stuff.</p>
</div>
<div class="section" id="actor-deployment-configuration">
<h2>Actor Deployment Configuration</h2>
<p>Deployment settings for specific actors can be defined in the <code class="docutils literal"><span class="pre">akka.actor.deployment</span></code>
section of the configuration. In the deployment section it is possible to define
things like dispatcher, mailbox, router settings, and remote deployment.
Configuration of these features are described in the chapters detailing corresponding
topics. An example may look like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span>akka.actor.deployment {

  # &#39;/user/actorA/actorB&#39; is a remote deployed actor
  /actorA/actorB {
    remote = &quot;akka.tcp://sampleActorSystem@127.0.0.1:2553&quot;
  }
  
  # all direct children of &#39;/user/actorC&#39; have a dedicated dispatcher 
  &quot;/actorC/*&quot; {
    dispatcher = my-dispatcher
  }
  
  # &#39;/user/actorD/actorE&#39; has a special priority mailbox
  /actorD/actorE {
    mailbox = prio-mailbox
  }
  
  # &#39;/user/actorF/actorG/actorH&#39; is a random pool
  /actorF/actorG/actorH {
    router = random-pool
    nr-of-instances = 5
  }
}

my-dispatcher {
  fork-join-executor.parallelism-min = 10
  fork-join-executor.parallelism-max = 10
}
prio-mailbox {
  mailbox-type = &quot;a.b.MyPrioMailbox&quot;
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The deployment section for a specific actor is identified by the
path of the actor relative to <code class="docutils literal"><span class="pre">/user</span></code>.</p>
</div>
<p>You can use asterisks as wildcard matches for the actor path sections, so you could specify:
<code class="docutils literal"><span class="pre">/*/sampleActor</span></code> and that would match all <code class="docutils literal"><span class="pre">sampleActor</span></code> on that level in the hierarchy.
You can also use wildcard in the last position to match all actors at a certain level:
<code class="docutils literal"><span class="pre">/someParent/*</span></code>. Non-wildcard matches always have higher priority to match than wildcards, so:
<code class="docutils literal"><span class="pre">/foo/bar</span></code> is considered <strong>more specific</strong> than <code class="docutils literal"><span class="pre">/foo/*</span></code> and only the highest priority match is used.
Please note that it <strong>cannot</strong> be used to partially match section, like this: <code class="docutils literal"><span class="pre">/foo*/bar</span></code>, <code class="docutils literal"><span class="pre">/f*o/bar</span></code> etc.</p>
</div>
<div class="section" id="listing-of-the-reference-configuration">
<h2>Listing of the Reference Configuration</h2>
<p>Each Akka module has a reference configuration file with the default values.</p>
<div class="section" id="akka-actor">
<span id="config-akka-actor"></span><h3>akka-actor</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>####################################
# Akka Actor Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  # Akka version, checked against the runtime version of Akka.
  version = &quot;2.3.15&quot;

  # Home directory of Akka, modules in the deploy directory will be loaded
  home = &quot;&quot;

  # Loggers to register at boot time (akka.event.Logging$DefaultLogger logs
  # to STDOUT)
  loggers = [&quot;akka.event.Logging$DefaultLogger&quot;]

  # Loggers are created and registered synchronously during ActorSystem
  # start-up, and since they are actors, this timeout is used to bound the
  # waiting time
  logger-startup-timeout = 5s

  # Log level used by the configured loggers (see &quot;loggers&quot;) as soon
  # as they have been started; before that, see &quot;stdout-loglevel&quot;
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = &quot;INFO&quot;

  # Log level for the very basic logger activated during ActorSystem startup.
  # This logger prints the log messages to stdout (System.out).
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  stdout-loglevel = &quot;WARNING&quot;

  # Log the complete configuration at INFO level when the actor system is started.
  # This is useful when you are uncertain of what configuration is used.
  log-config-on-start = off

  # Log at info level when messages are sent to dead letters.
  # Possible values:
  # on: all dead letters are logged
  # off: no logging of dead letters
  # n: positive integer, number of dead letters that will be logged
  log-dead-letters = 10

  # Possibility to turn off logging of dead letters while the actor system
  # is shutting down. Logging is only done when enabled by &#39;log-dead-letters&#39;
  # setting.
  log-dead-letters-during-shutdown = on

  # List FQCN of extensions which shall be loaded at actor system startup.
  # Should be on the format: &#39;extensions = [&quot;foo&quot;, &quot;bar&quot;]&#39; etc.
  # See the Akka Documentation for more info about Extensions
  extensions = []

  # Toggles whether threads created by this ActorSystem should be daemons or not
  daemonic = off

  # JVM shutdown, System.exit(-1), in case of a fatal error,
  # such as OutOfMemoryError
  jvm-exit-on-fatal-error = on

  actor {

    # FQCN of the ActorRefProvider to be used; the below is the built-in default,
    # another one is akka.remote.RemoteActorRefProvider in the akka-remote bundle.
    provider = &quot;akka.actor.LocalActorRefProvider&quot;

    # The guardian &quot;/user&quot; will use this class to obtain its supervisorStrategy.
    # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
    # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
    guardian-supervisor-strategy = &quot;akka.actor.DefaultSupervisorStrategy&quot;

    # Timeout for ActorSystem.actorOf
    creation-timeout = 20s

    # Frequency with which stopping actors are prodded in case they had to be
    # removed from their parents
    reaper-interval = 5s

    # Serializes and deserializes (non-primitive) messages to ensure immutability,
    # this is only intended for testing.
    serialize-messages = off

    # Serializes and deserializes creators (in Props) to ensure that they can be
    # sent over the network, this is only intended for testing. Purely local deployments
    # as marked with deploy.scope == LocalScope are exempt from verification.
    serialize-creators = off

    # Timeout for send operations to top-level actors which are in the process
    # of being started. This is only relevant if using a bounded mailbox or the
    # CallingThreadDispatcher for a top-level actor.
    unstarted-push-timeout = 10s

    typed {
      # Default timeout for typed actor methods with non-void return type
      timeout = 5s
    }
    
    # Mapping between ´deployment.router&#39; short names to fully qualified class names
    router.type-mapping {
      from-code = &quot;akka.routing.NoRouter&quot;
      round-robin-pool = &quot;akka.routing.RoundRobinPool&quot;
      round-robin-group = &quot;akka.routing.RoundRobinGroup&quot;
      random-pool = &quot;akka.routing.RandomPool&quot;
      random-group = &quot;akka.routing.RandomGroup&quot;
      balancing-pool = &quot;akka.routing.BalancingPool&quot;
      smallest-mailbox-pool = &quot;akka.routing.SmallestMailboxPool&quot;
      broadcast-pool = &quot;akka.routing.BroadcastPool&quot;
      broadcast-group = &quot;akka.routing.BroadcastGroup&quot;
      scatter-gather-pool = &quot;akka.routing.ScatterGatherFirstCompletedPool&quot;
      scatter-gather-group = &quot;akka.routing.ScatterGatherFirstCompletedGroup&quot;
      tail-chopping-pool = &quot;akka.routing.TailChoppingPool&quot;
      tail-chopping-group = &quot;akka.routing.TailChoppingGroup&quot;
      consistent-hashing-pool = &quot;akka.routing.ConsistentHashingPool&quot;
      consistent-hashing-group = &quot;akka.routing.ConsistentHashingGroup&quot;
    }

    deployment {

      # deployment id pattern - on the format: /parent/child etc.
      default {
      
        # The id of the dispatcher to use for this actor.
        # If undefined or empty the dispatcher specified in code
        # (Props.withDispatcher) is used, or default-dispatcher if not
        # specified at all.
        dispatcher = &quot;&quot;

        # The id of the mailbox to use for this actor.
        # If undefined or empty the default mailbox of the configured dispatcher
        # is used or if there is no mailbox configuration the mailbox specified
        # in code (Props.withMailbox) is used.
        # If there is a mailbox defined in the configured dispatcher then that
        # overrides this setting.
        mailbox = &quot;&quot;

        # routing (load-balance) scheme to use
        # - available: &quot;from-code&quot;, &quot;round-robin&quot;, &quot;random&quot;, &quot;smallest-mailbox&quot;,
        #              &quot;scatter-gather&quot;, &quot;broadcast&quot;
        # - or:        Fully qualified class name of the router class.
        #              The class must extend akka.routing.CustomRouterConfig and
        #              have a public constructor with com.typesafe.config.Config
        #              and optional akka.actor.DynamicAccess parameter.
        # - default is &quot;from-code&quot;;
        # Whether or not an actor is transformed to a Router is decided in code
        # only (Props.withRouter). The type of router can be overridden in the
        # configuration; specifying &quot;from-code&quot; means that the values specified
        # in the code shall be used.
        # In case of routing, the actors to be routed to can be specified
        # in several ways:
        # - nr-of-instances: will create that many children
        # - routees.paths: will route messages to these paths using ActorSelection,
        #   i.e. will not create children
        # - resizer: dynamically resizable number of routees as specified in
        #   resizer below
        router = &quot;from-code&quot;

        # number of children to create in case of a router;
        # this setting is ignored if routees.paths is given
        nr-of-instances = 1

        # within is the timeout used for routers containing future calls
        within = 5 seconds

        # number of virtual nodes per node for consistent-hashing router
        virtual-nodes-factor = 10

        tail-chopping-router {
          # interval is duration between sending message to next routee
          interval = 10 milliseconds
        }

        routees {
          # Alternatively to giving nr-of-instances you can specify the full
          # paths of those actors which should be routed to. This setting takes
          # precedence over nr-of-instances
          paths = []
        }
        
        # To use a dedicated dispatcher for the routees of the pool you can
        # define the dispatcher configuration inline with the property name 
        # &#39;pool-dispatcher&#39; in the deployment section of the router.
        # For example:
        # pool-dispatcher {
        #   fork-join-executor.parallelism-min = 5
        #   fork-join-executor.parallelism-max = 5
        # }

        # Routers with dynamically resizable number of routees; this feature is
        # enabled by including (parts of) this section in the deployment
        resizer {
        
          enabled = off

          # The fewest number of routees the router should ever have.
          lower-bound = 1

          # The most number of routees the router should ever have.
          # Must be greater than or equal to lower-bound.
          upper-bound = 10

          # Threshold used to evaluate if a routee is considered to be busy
          # (under pressure). Implementation depends on this value (default is 1).
          # 0:   number of routees currently processing a message.
          # 1:   number of routees currently processing a message has
          #      some messages in mailbox.
          # &gt; 1: number of routees with at least the configured pressure-threshold
          #      messages in their mailbox. Note that estimating mailbox size of
          #      default UnboundedMailbox is O(N) operation.
          pressure-threshold = 1

          # Percentage to increase capacity whenever all routees are busy.
          # For example, 0.2 would increase 20% (rounded up), i.e. if current
          # capacity is 6 it will request an increase of 2 more routees.
          rampup-rate = 0.2

          # Minimum fraction of busy routees before backing off.
          # For example, if this is 0.3, then we&#39;ll remove some routees only when
          # less than 30% of routees are busy, i.e. if current capacity is 10 and
          # 3 are busy then the capacity is unchanged, but if 2 or less are busy
          # the capacity is decreased.
          # Use 0.0 or negative to avoid removal of routees.
          backoff-threshold = 0.3

          # Fraction of routees to be removed when the resizer reaches the
          # backoffThreshold.
          # For example, 0.1 would decrease 10% (rounded up), i.e. if current
          # capacity is 9 it will request an decrease of 1 routee.
          backoff-rate = 0.1

          # Number of messages between resize operation.
          # Use 1 to resize before each message.
          messages-per-resize = 10
        }
      }
    }

    default-dispatcher {
      # Must be one of the following
      # Dispatcher, PinnedDispatcher, or a FQCN to a class inheriting
      # MessageDispatcherConfigurator with a public constructor with
      # both com.typesafe.config.Config parameter and
      # akka.dispatch.DispatcherPrerequisites parameters.
      # PinnedDispatcher must be used together with executor=thread-pool-executor.
      type = &quot;Dispatcher&quot;

      # Which kind of ExecutorService to use for this dispatcher
      # Valid options:
      #  - &quot;default-executor&quot; requires a &quot;default-executor&quot; section
      #  - &quot;fork-join-executor&quot; requires a &quot;fork-join-executor&quot; section
      #  - &quot;thread-pool-executor&quot; requires a &quot;thread-pool-executor&quot; section
      #  - A FQCN of a class extending ExecutorServiceConfigurator
      executor = &quot;default-executor&quot;

      # This will be used if you have set &quot;executor = &quot;default-executor&quot;&quot;.
      # If an ActorSystem is created with a given ExecutionContext, this
      # ExecutionContext will be used as the default executor for all
      # dispatchers in the ActorSystem configured with
      # executor = &quot;default-executor&quot;. Note that &quot;default-executor&quot;
      # is the default value for executor, and therefore used if not
      # specified otherwise. If no ExecutionContext is given,
      # the executor configured in &quot;fallback&quot; will be used.
      default-executor {
        fallback = &quot;fork-join-executor&quot;
      }

      # This will be used if you have set &quot;executor = &quot;fork-join-executor&quot;&quot;
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 8

        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values.
        parallelism-factor = 3.0

        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 64

        # Setting to &quot;FIFO&quot; to use queue like peeking mode which &quot;poll&quot; or &quot;LIFO&quot; to use stack
        # like peeking mode which &quot;pop&quot;.
        task-peeking-mode = &quot;FIFO&quot;
      }

      # This will be used if you have set &quot;executor = &quot;thread-pool-executor&quot;&quot;
      thread-pool-executor {
        # Keep alive time for threads
        keep-alive-time = 60s

        # Min number of threads to cap factor-based core number to
        core-pool-size-min = 8

        # The core pool size factor is used to determine thread pool core size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the core-pool-size-min and
        # core-pool-size-max values.
        core-pool-size-factor = 3.0

        # Max number of threads to cap factor-based number to
        core-pool-size-max = 64

        # Minimum number of threads to cap factor-based max number to
        # (if using a bounded task queue)
        max-pool-size-min = 8

        # Max no of threads (if using a bounded task queue) is determined by
        # calculating: ceil(available processors * factor)
        max-pool-size-factor  = 3.0

        # Max number of threads to cap factor-based max number to
        # (if using a  bounded task queue)
        max-pool-size-max = 64

        # Specifies the bounded capacity of the task queue (&lt; 1 == unbounded)
        task-queue-size = -1

        # Specifies which type of task queue will be used, can be &quot;array&quot; or
        # &quot;linked&quot; (default)
        task-queue-type = &quot;linked&quot;

        # Allow core threads to time out
        allow-core-timeout = on
      }

      # How long time the dispatcher will wait for new actors until it shuts down
      shutdown-timeout = 1s

      # Throughput defines the number of messages that are processed in a batch
      # before the thread is returned to the pool. Set to 1 for as fair as possible.
      throughput = 5

      # Throughput deadline for Dispatcher, set to 0 or negative for no deadline
      throughput-deadline-time = 0ms

      # For BalancingDispatcher: If the balancing dispatcher should attempt to
      # schedule idle actors using the same dispatcher when a message comes in,
      # and the dispatchers ExecutorService is not fully busy already.
      attempt-teamwork = on

      # If this dispatcher requires a specific type of mailbox, specify the
      # fully-qualified class name here; the actually created mailbox will
      # be a subtype of this type. The empty string signifies no requirement.
      mailbox-requirement = &quot;&quot;
    }

    default-mailbox {
      # FQCN of the MailboxType. The Class of the FQCN must have a public
      # constructor with
      # (akka.actor.ActorSystem.Settings, com.typesafe.config.Config) parameters.
      mailbox-type = &quot;akka.dispatch.UnboundedMailbox&quot;

      # If the mailbox is bounded then it uses this setting to determine its
      # capacity. The provided value must be positive.
      # NOTICE:
      # Up to version 2.1 the mailbox type was determined based on this setting;
      # this is no longer the case, the type must explicitly be a bounded mailbox.
      mailbox-capacity = 1000

      # If the mailbox is bounded then this is the timeout for enqueueing
      # in case the mailbox is full. Negative values signify infinite
      # timeout, which should be avoided as it bears the risk of dead-lock.
      mailbox-push-timeout-time = 10s

      # For Actor with Stash: The default capacity of the stash.
      # If negative (or zero) then an unbounded stash is used (default)
      # If positive then a bounded stash is used and the capacity is set using
      # the property
      stash-capacity = -1
    }

    mailbox {
      # Mapping between message queue semantics and mailbox configurations.
      # Used by akka.dispatch.RequiresMessageQueue[T] to enforce different
      # mailbox types on actors.
      # If your Actor implements RequiresMessageQueue[T], then when you create
      # an instance of that actor its mailbox type will be decided by looking
      # up a mailbox configuration via T in this mapping
      requirements {
        &quot;akka.dispatch.UnboundedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-queue-based
        &quot;akka.dispatch.BoundedMessageQueueSemantics&quot; =
          akka.actor.mailbox.bounded-queue-based
        &quot;akka.dispatch.DequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-deque-based
        &quot;akka.dispatch.UnboundedDequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.unbounded-deque-based
        &quot;akka.dispatch.BoundedDequeBasedMessageQueueSemantics&quot; =
          akka.actor.mailbox.bounded-deque-based
        &quot;akka.dispatch.MultipleConsumerSemantics&quot; =
          akka.actor.mailbox.unbounded-queue-based
      }

      unbounded-queue-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.UnboundedMailbox&quot;
      }

      bounded-queue-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.BoundedMailbox&quot;
      }

      unbounded-deque-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.UnboundedDequeBasedMailbox&quot;
      }

      bounded-deque-based {
        # FQCN of the MailboxType, The Class of the FQCN must have a public
        # constructor with (akka.actor.ActorSystem.Settings,
        # com.typesafe.config.Config) parameters.
        mailbox-type = &quot;akka.dispatch.BoundedDequeBasedMailbox&quot;
      }
    }

    debug {
      # enable function of Actor.loggable(), which is to log any received message
      # at DEBUG level, see the “Testing Actor Systems” section of the Akka
      # Documentation at http://akka.io/docs
      receive = off

      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      autoreceive = off

      # enable DEBUG logging of actor lifecycle changes
      lifecycle = off

      # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      fsm = off

      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = off

      # enable DEBUG logging of unhandled messages
      unhandled = off

      # enable WARN logging of misconfigured routers
      router-misconfiguration = off
    }

    # Entries for pluggable serializers and their bindings.
    serializers {
      java = &quot;akka.serialization.JavaSerializer&quot;
      bytes = &quot;akka.serialization.ByteArraySerializer&quot;
    }

    # Class to Serializer binding. You only need to specify the name of an
    # interface or abstract base class of the messages. In case of ambiguity it
    # is using the most specific configured class, or giving a warning and
    # choosing the “first” one.
    #
    # To disable one of the default serializers, assign its class to &quot;none&quot;, like
    # &quot;java.io.Serializable&quot; = none
    serialization-bindings {
      &quot;[B&quot; = bytes
      &quot;java.io.Serializable&quot; = java
    }

    # Configuration items which are used by the akka.actor.ActorDSL._ methods
    dsl {
      # Maximum queue size of the actor created by newInbox(); this protects
      # against faulty programs which use select() and consistently miss messages
      inbox-size = 1000

      # Default timeout to assume for operations like Inbox.receive et al
      default-timeout = 5s
    }
  }

  # Used to set the behavior of the scheduler.
  # Changing the default values may change the system behavior drastically so make
  # sure you know what you&#39;re doing! See the Scheduler section of the Akka
  # Documentation for more details.
  scheduler {
    # The LightArrayRevolverScheduler is used as the default scheduler in the
    # system. It does not execute the scheduled tasks on exact time, but on every
    # tick, it will run everything that is (over)due. You can increase or decrease
    # the accuracy of the execution timing by specifying smaller or larger tick
    # duration. If you are scheduling a lot of tasks you should consider increasing
    # the ticks per wheel.
    # Note that it might take up to 1 tick to stop the Timer, so setting the
    # tick-duration to a high value will make shutting down the actor system
    # take longer.
    tick-duration = 10ms

    # The timer uses a circular wheel of buckets to store the timer tasks.
    # This should be set such that the majority of scheduled timeouts (for high
    # scheduling frequency) will be shorter than one rotation of the wheel
    # (ticks-per-wheel * ticks-duration)
    # THIS MUST BE A POWER OF TWO!
    ticks-per-wheel = 512

    # This setting selects the timer implementation which shall be loaded at
    # system start-up.
    # The class given here must implement the akka.actor.Scheduler interface
    # and offer a public constructor which takes three arguments:
    #  1) com.typesafe.config.Config
    #  2) akka.event.LoggingAdapter
    #  3) java.util.concurrent.ThreadFactory
    implementation = akka.actor.LightArrayRevolverScheduler

    # When shutting down the scheduler, there will typically be a thread which
    # needs to be stopped, and this timeout determines how long to wait for
    # that to happen. In case of timeout the shutdown of the actor system will
    # proceed without running possibly still enqueued tasks.
    shutdown-timeout = 5s
  }

  io {

    # By default the select loops run on dedicated threads, hence using a
    # PinnedDispatcher
    pinned-dispatcher {
      type = &quot;PinnedDispatcher&quot;
      executor = &quot;thread-pool-executor&quot;
      thread-pool-executor.allow-core-timeout = off
    }

    tcp {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this TCP module; there is
      # no intrinsic general limit, this setting is meant to enable DoS
      # protection by limiting the number of concurrently connected clients.
      # Also note that this is a &quot;soft&quot; limit; in certain cases the implementation
      # will accept a few connections more or a few less than the number configured
      # here. Must be an integer &gt; 0 or &quot;unlimited&quot;.
      max-channels = 256000

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of connection that are accepted in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      batch-accept-limit = 10

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The duration a connection actor waits for a `Register` message from
      # its commander before aborting the connection.
      register-timeout = 5s

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      # The purpose of this setting is to impose a smaller limit than the 
      # configured receive buffer size. When using value &#39;unlimited&#39; it will
      # try to read all from the receive buffer.
      max-received-message-size = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # on which file IO tasks are scheduled
      file-io-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # The maximum number of bytes (or &quot;unlimited&quot;) to transfer in one batch
      # when using `WriteFile` command which uses `FileChannel.transferTo` to
      # pipe files to a TCP socket. On some OS like Linux `FileChannel.transferTo`
      # may block for a long time when network IO is faster than file IO.
      # Decreasing the value may improve fairness while increasing may improve
      # throughput.
      file-io-transferTo-limit = 512 KiB

      # The number of times to retry the `finishConnect` call after being notified about
      # OP_CONNECT. Retries are needed if the OP_CONNECT notification doesn&#39;t imply that
      # `finishConnect` will succeed, which is the case on Android.
      finish-connect-retries = 5

      # On Windows connection aborts are not reliably detected unless an OP_READ is
      # registered on the selector _after_ the connection has been reset. This
      # workaround enables an OP_CONNECT which forces the abort to be visible on Windows.
      # Enabling this setting on other platforms than Windows will cause various failures
      # and undefined behavior.
      # Possible values of this key are on, off and auto where auto will enable the
      # workaround if Windows is detected automatically.
      windows-connection-abort-workaround-enabled = off
    }

    udp {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this UDP module Generally
      # UDP does not require a large number of channels, therefore it is
      # recommended to keep this setting low.
      max-channels = 4096

      # The select loop can be used in two modes:
      # - setting &quot;infinite&quot; will select without a timeout, hogging a thread
      # - setting a positive timeout will do a bounded select call,
      #   enabling sharing of a single thread between multiple selectors
      #   (in this case you will have to use a different configuration for the
      #   selector-dispatcher, e.g. using &quot;type=Dispatcher&quot; with size 1)
      # - setting it to zero means polling, i.e. calling selectNow()
      select-timeout = infinite

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of datagrams that are read in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      receive-throughput = 3

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      received-message-size-limit = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;
    }

    udp-connected {

      # The number of selectors to stripe the served channels over; each of
      # these will use one select loop on the selector-dispatcher.
      nr-of-selectors = 1

      # Maximum number of open channels supported by this UDP module Generally
      # UDP does not require a large number of channels, therefore it is
      # recommended to keep this setting low.
      max-channels = 4096

      # The select loop can be used in two modes:
      # - setting &quot;infinite&quot; will select without a timeout, hogging a thread
      # - setting a positive timeout will do a bounded select call,
      #   enabling sharing of a single thread between multiple selectors
      #   (in this case you will have to use a different configuration for the
      #   selector-dispatcher, e.g. using &quot;type=Dispatcher&quot; with size 1)
      # - setting it to zero means polling, i.e. calling selectNow()
      select-timeout = infinite

      # When trying to assign a new connection to a selector and the chosen
      # selector is at full capacity, retry selector choosing and assignment
      # this many times before giving up
      selector-association-retries = 10

      # The maximum number of datagrams that are read in one go,
      # higher numbers decrease latency, lower numbers increase fairness on
      # the worker-dispatcher
      receive-throughput = 3

      # The number of bytes per direct buffer in the pool used to read or write
      # network data from the kernel.
      direct-buffer-size = 128 KiB

      # The maximal number of direct buffers kept in the direct buffer pool for
      # reuse.
      direct-buffer-pool-limit = 1000

      # The maximum number of bytes delivered by a `Received` message. Before
      # more data is read from the network the connection actor will try to
      # do other work.
      received-message-size-limit = unlimited

      # Enable fine grained logging of what goes on inside the implementation.
      # Be aware that this may log more than once per message sent to the actors
      # of the tcp implementation.
      trace-logging = off

      # Fully qualified config path which holds the dispatcher configuration
      # to be used for running the select() calls in the selectors
      selector-dispatcher = &quot;akka.io.pinned-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the read/write worker actors
      worker-dispatcher = &quot;akka.actor.default-dispatcher&quot;

      # Fully qualified config path which holds the dispatcher configuration
      # for the selector management actors
      management-dispatcher = &quot;akka.actor.default-dispatcher&quot;
    }

  }


}
</pre></div>
</div>
</div>
<div class="section" id="akka-agent">
<span id="config-akka-agent"></span><h3>akka-agent</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>####################################
# Akka Agent Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  agent {

    # The dispatcher used for agent-send-off actor
    send-off-dispatcher {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }

    # The dispatcher used for agent-alter-off actor
    alter-off-dispatcher {
      executor = thread-pool-executor
      type = PinnedDispatcher
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-camel">
<span id="config-akka-camel"></span><h3>akka-camel</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>####################################
# Akka Camel Reference Config File #
####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  camel {
    # FQCN of the ContextProvider to be used to create or locate a CamelContext
    # it must implement akka.camel.ContextProvider and have a no-arg constructor
    # the built-in default create a fresh DefaultCamelContext
    context-provider = akka.camel.DefaultContextProvider

    # Whether JMX should be enabled or disabled for the Camel Context
    jmx = off
    # enable/disable streaming cache on the Camel Context
    streamingCache = on
    consumer {
      # Configured setting which determines whether one-way communications
      # between an endpoint and this consumer actor
      # should be auto-acknowledged or application-acknowledged.
      # This flag has only effect when exchange is in-only.
      auto-ack = on

      # When endpoint is out-capable (can produce responses) reply-timeout is the
      # maximum time the endpoint can take to send the response before the message
      # exchange fails. This setting is used for out-capable, in-only,
      # manually acknowledged communication.
      reply-timeout = 1m

      # The duration of time to await activation of an endpoint.
      activation-timeout = 10s
    }

    #Scheme to FQCN mappings for CamelMessage body conversions
    conversions {
      &quot;file&quot; = &quot;java.io.InputStream&quot;
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-cluster">
<span id="config-akka-cluster"></span><h3>akka-cluster</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>######################################
# Akka Cluster Reference Config File #
######################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {

  cluster {
    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # &quot;akka.tcp://system@hostname:port&quot;
    # Leave as empty if the node is supposed to be joined manually.
    seed-nodes = []

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 5s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying &quot;off&quot;.
    retry-unsuccessful-join-after = 10s

    # Should the &#39;leader&#39; in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN after a configured time of unreachability?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.
    # Disable with &quot;off&quot; or specify a duration to enable auto-down.
    auto-down-unreachable-after = off
    
    # deprecated in 2.3, use &#39;auto-down-unreachable-after&#39; instead
    auto-down = off 

    # The roles of this member. List of strings, e.g. roles = [&quot;A&quot;, &quot;B&quot;].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
      # Minimum required number of members of a certain role before the leader
      # changes member status of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together
      # with &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting
      # actors, until the cluster has reached a certain size.
      # E.g. to require 2 nodes with role &#39;frontend&#39; and 3 nodes with role &#39;backend&#39;:
      #   frontend.min-nr-of-members = 2
      #   backend.min-nr-of-members = 3
      #&lt;role-name&gt;.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of &#39;Joining&#39; members to &#39;Up&#39;. Typically used together with
    # &#39;Cluster.registerOnMemberUp&#39; to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = on

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 1s
    
    # discard incoming gossip messages if not handled within this duration
    gossip-time-to-live = 2s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 1s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 1s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with &quot;off&quot;.
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = &quot;&quot;

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8
    
    # Reduced the above probability when the number of nodes in the cluster
    # greater than this value.
    reduce-gossip-different-view-probability = 400

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 8.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 1000

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 3 s

      # Number of member nodes that each member will send heartbeat messages to,
      # i.e. each node will be monitored by this number of other nodes.
      monitored-by-nr-of-members = 5
      
      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat mesage has
      # been received.
      expected-response-after = 5 s

    }

    metrics {
      # Enable or disable metrics collector for load-balancing nodes.
      enabled = on

      # FQCN of the metrics collector implementation.
      # It must implement akka.cluster.MetricsCollector and
      # have public constructor with akka.actor.ActorSystem parameter.
      # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
      # is on the classpath, otherwise only JMX.
      collector-class = &quot;akka.cluster.SigarMetricsCollector&quot;

      # How often metrics are sampled on a node.
      # Shorter interval will collect the metrics more often.
      collect-interval = 3s

      # How often a node publishes metrics information.
      gossip-interval = 3s

      # How quickly the exponential weighting of past data is decayed compared to
      # new data. Set lower to increase the bias toward newer values.
      # The relevance of each data sample is halved for every passing half-life
      # duration, i.e. after 4 times the half-life, a data sample’s relevance is
      # reduced to 6% of its original relevance. The initial relevance of a data
      # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
      # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
      moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
      tick-duration = 33ms
      ticks-per-wheel = 512
    }

  }

  # Default configuration for routers
  actor.deployment.default {
    # MetricsSelector to use
    # - available: &quot;mix&quot;, &quot;heap&quot;, &quot;cpu&quot;, &quot;load&quot;
    # - or: Fully qualified class name of the MetricsSelector class.
    #       The class must extend akka.cluster.routing.MetricsSelector
    #       and have a public constructor with com.typesafe.config.Config
    #       parameter.
    # - default is &quot;mix&quot;
    metrics-selector = mix
  }
  actor.deployment.default.cluster {
    # enable cluster aware router that deploys to nodes in the cluster
    enabled = off

    # Maximum number of routees that will be deployed on each cluster
    # member node.
    # Note that nr-of-instances defines total number of routees, but
    # number of routees per node will not be exceeded, i.e. if you
    # define nr-of-instances = 50 and max-nr-of-instances-per-node = 2
    # it will deploy 2 routees per new member in the cluster, up to
    # 25 members.
    max-nr-of-instances-per-node = 1

    # Defines if routees are allowed to be located on the same node as
    # the head router actor, or only on remote nodes.
    # Useful for master-worker scenario where all routees are remote.
    allow-local-routees = on

    # Deprecated in 2.3, use routees.paths instead
    routees-path = &quot;&quot;

    # Use members with specified role, or all members if undefined or empty.
    use-role = &quot;&quot;

  }

  # Protobuf serializer for cluster messages
  actor {
    serializers {
      akka-cluster = &quot;akka.cluster.protobuf.ClusterMessageSerializer&quot;
    }

    serialization-bindings {
      &quot;akka.cluster.ClusterMessage&quot; = akka-cluster
    }
    
    router.type-mapping {
      adaptive-pool = &quot;akka.cluster.routing.AdaptiveLoadBalancingPool&quot;
      adaptive-group = &quot;akka.cluster.routing.AdaptiveLoadBalancingGroup&quot;
    }
  }

}
</pre></div>
</div>
</div>
<div class="section" id="akka-multi-node-testkit">
<span id="config-akka-multi-node-testkit"></span><h3>akka-multi-node-testkit</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>#############################################
# Akka Remote Testing Reference Config File #
#############################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  testconductor {

    # Timeout for joining a barrier: this is the maximum time any participants
    # waits for everybody else to join a named barrier.
    barrier-timeout = 30s
    
    # Timeout for interrogation of TestConductor’s Controller actor
    query-timeout = 5s
    
    # Threshold for packet size in time unit above which the failure injector will
    # split the packet and deliver in smaller portions; do not give value smaller
    # than HashedWheelTimer resolution (would not make sense)
    packet-split-threshold = 100ms
    
    # amount of time for the ClientFSM to wait for the connection to the conductor
    # to be successful
    connect-timeout = 20s
    
    # Number of connect attempts to be made to the conductor controller
    client-reconnects = 10
    
    # minimum time interval which is to be inserted between reconnect attempts
    reconnect-backoff = 1s

    netty {
      # (I&amp;O) Used to configure the number of I/O worker threads on server sockets
      server-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 1

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }

      # (I&amp;O) Used to configure the number of I/O worker threads on client sockets
      client-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 1

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-persistence">
<span id="config-akka-persistence"></span><h3>akka-persistence</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>##########################################
# Akka Persistence Reference Config File #
##########################################



akka {

  # Protobuf serialization for persistent messages
  actor {

    serializers {

      akka-persistence-snapshot = &quot;akka.persistence.serialization.SnapshotSerializer&quot;
      akka-persistence-message = &quot;akka.persistence.serialization.MessageSerializer&quot;
    }

    serialization-bindings {

      &quot;akka.persistence.serialization.Snapshot&quot; = akka-persistence-snapshot
      &quot;akka.persistence.serialization.Message&quot; = akka-persistence-message
    }
  }

  persistence {

    journal {

      # Maximum size of a persistent message batch written to the journal.
      max-message-batch-size = 200

      # Maximum size of a confirmation batch written to the journal.
      max-confirmation-batch-size = 10000

      # Maximum size of a deletion batch written to the journal.
      max-deletion-batch-size = 10000

      # Path to the journal plugin to be used
      plugin = &quot;akka.persistence.journal.leveldb&quot;

      # In-memory journal plugin.
      inmem {

        # Class name of the plugin.
        class = &quot;akka.persistence.journal.inmem.InmemJournal&quot;

        # Dispatcher for the plugin actor.
        plugin-dispatcher = &quot;akka.actor.default-dispatcher&quot;
      }

      # LevelDB journal plugin.
      leveldb {

        # Class name of the plugin.
        class = &quot;akka.persistence.journal.leveldb.LeveldbJournal&quot;

        # Dispatcher for the plugin actor.
        plugin-dispatcher = &quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;

        # Dispatcher for message replay.
        replay-dispatcher = &quot;akka.persistence.dispatchers.default-replay-dispatcher&quot;

        # Storage location of LevelDB files.
        dir = &quot;journal&quot;

        # Use fsync on write
        fsync = on

        # Verify checksum on read.
        checksum = off

        # Native LevelDB (via JNI) or LevelDB Java port
        native = on
      }

      # Shared LevelDB journal plugin (for testing only).
      leveldb-shared {

        # Class name of the plugin.
        class = &quot;akka.persistence.journal.leveldb.SharedLeveldbJournal&quot;

        # Dispatcher for the plugin actor.
        plugin-dispatcher = &quot;akka.actor.default-dispatcher&quot;
        
        # timeout for async journal operations
        timeout = 10s

        store {

          # Dispatcher for shared store actor.
          store-dispatcher = &quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;

          # Dispatcher for message replay.
          replay-dispatcher = &quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;

          # Storage location of LevelDB files.
          dir = &quot;journal&quot;

          # Use fsync on write
          fsync = on

          # Verify checksum on read.
          checksum = off

          # Native LevelDB (via JNI) or LevelDB Java port
          native = on
        }
      }
    }

    snapshot-store {

      # Path to the snapshot store plugin to be used
      plugin = &quot;akka.persistence.snapshot-store.local&quot;

      # Local filesystem snapshot store plugin.
      local {

        # Class name of the plugin.
        class = &quot;akka.persistence.snapshot.local.LocalSnapshotStore&quot;

        # Dispatcher for the plugin actor.
        plugin-dispatcher = &quot;akka.persistence.dispatchers.default-plugin-dispatcher&quot;

        # Dispatcher for streaming snapshot IO.
        stream-dispatcher = &quot;akka.persistence.dispatchers.default-stream-dispatcher&quot;

        # Storage location of snapshot files.
        dir = &quot;snapshots&quot;
      }
    }

    view {

      # Automated incremental view update.
      auto-update = on

      # Interval between incremental updates
      auto-update-interval = 5s

      # Maximum number of messages to replay per incremental view update. Set to
      # -1 for no upper limit.
      auto-update-replay-max = -1
    }
    
    at-least-once-delivery {
      # Interval between redelivery attempts
      redeliver-interval = 5s
      
      # After this number of delivery attempts a `ReliableRedelivery.UnconfirmedWarning`
      # message will be sent to the actor.
      warn-after-number-of-unconfirmed-attempts = 5
      
      # Maximum number of unconfirmed messages that an actor with AtLeastOnceDelivery is
      # allowed to hold in memory.
      max-unconfirmed-messages = 100000
    }

    dispatchers {
      default-plugin-dispatcher {
        type = PinnedDispatcher
        executor = &quot;thread-pool-executor&quot;
      }
      default-replay-dispatcher {
        type = Dispatcher
        executor = &quot;fork-join-executor&quot;
        fork-join-executor {
          parallelism-min = 2
          parallelism-max = 8
        }
      }
      default-stream-dispatcher {
        type = Dispatcher
        executor = &quot;fork-join-executor&quot;
        fork-join-executor {
          parallelism-min = 2
          parallelism-max = 8
        }
      }
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-remote">
<span id="config-akka-remote"></span><h3>akka-remote</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>#####################################
# Akka Remote Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

# comments about akka.actor settings left out where they are already in akka-
# actor.jar, because otherwise they would be repeated in config rendering.

akka {

  actor {

    serializers {
      akka-containers = &quot;akka.remote.serialization.MessageContainerSerializer&quot;
      proto = &quot;akka.remote.serialization.ProtobufSerializer&quot;
      daemon-create = &quot;akka.remote.serialization.DaemonMsgCreateSerializer&quot;
    }


    serialization-bindings {
      # Since com.google.protobuf.Message does not extend Serializable but
      # GeneratedMessage does, need to use the more specific one here in order
      # to avoid ambiguity
      &quot;akka.actor.ActorSelectionMessage&quot; = akka-containers
      &quot;com.google.protobuf.GeneratedMessage&quot; = proto
      &quot;akka.remote.DaemonMsgCreate&quot; = daemon-create
    }

    deployment {

      default {

        # if this is set to a valid remote address, the named actor will be
        # deployed at that node e.g. &quot;akka.tcp://sys@host:port&quot;
        remote = &quot;&quot;

        target {

          # A list of hostnames and ports for instantiating the children of a
          # router
          #   The format should be on &quot;akka.tcp://sys@host:port&quot;, where:
          #    - sys is the remote actor system name
          #    - hostname can be either hostname or IP address the remote actor
          #      should connect to
          #    - port should be the port for the remote server on the other node
          # The number of actor instances to be spawned is still taken from the
          # nr-of-instances setting as for local routers; the instances will be
          # distributed round-robin among the given nodes.
          nodes = []

        }
      }
    }
  }

  remote {

    ### General settings

    # Timeout after which the startup of the remoting subsystem is considered
    # to be failed. Increase this value if your transport drivers (see the
    # enabled-transports section) need longer time to be loaded.
    startup-timeout = 10 s

    # Timout after which the graceful shutdown of the remoting subsystem is
    # considered to be failed. After the timeout the remoting system is
    # forcefully shut down. Increase this value if your transport drivers
    # (see the enabled-transports section) need longer time to stop properly.
    shutdown-timeout = 10 s

    # Before shutting down the drivers, the remoting subsystem attempts to flush
    # all pending writes. This setting controls the maximum time the remoting is
    # willing to wait before moving on to shut down the drivers.
    flush-wait-on-shutdown = 2 s

    # Reuse inbound connections for outbound messages
    use-passive-connections = on

    # Controls the backoff interval after a refused write is reattempted.
    # (Transports may refuse writes if their internal buffer is full)
    backoff-interval = 5 ms

    # Acknowledgment timeout of management commands sent to the transport stack.
    command-ack-timeout = 30 s
    
    # The timeout for outbound associations to perform the handshake.
    # If the transport is akka.remote.netty.tcp or akka.remote.netty.ssl
    # the configured connection-timeout for the transport will be used instead.
    handshake-timeout = 15 s

    # If set to a nonempty string remoting will use the given dispatcher for
    # its internal actors otherwise the default dispatcher is used. Please note
    # that since remoting can load arbitrary 3rd party drivers (see
    # &quot;enabled-transport&quot; and &quot;adapters&quot; entries) it is not guaranteed that
    # every module will respect this setting.
    use-dispatcher = &quot;akka.remote.default-remote-dispatcher&quot;

    ### Security settings

    # Enable untrusted mode for full security of server managed actors, prevents
    # system messages to be send by clients, e.g. messages like &#39;Create&#39;,
    # &#39;Suspend&#39;, &#39;Resume&#39;, &#39;Terminate&#39;, &#39;Supervise&#39;, &#39;Link&#39; etc.
    untrusted-mode = off
    
    # When &#39;untrusted-mode=on&#39; inbound actor selections are by default discarded.
    # Actors with paths defined in this white list are granted permission to receive actor
    # selections messages. 
    # E.g. trusted-selection-paths = [&quot;/user/receptionist&quot;, &quot;/user/namingService&quot;]   
    trusted-selection-paths = []

    # Should the remote server require that its peers share the same
    # secure-cookie (defined in the &#39;remote&#39; section)? Secure cookies are passed
    # between during the initial handshake. Connections are refused if the initial
    # message contains a mismatching cookie or the cookie is missing.
    require-cookie = off

    # Generate your own with the script availbale in
    # &#39;$AKKA_HOME/scripts/generate_config_with_secure_cookie.sh&#39; or using
    # &#39;akka.util.Crypt.generateSecureCookie&#39;
    secure-cookie = &quot;&quot;

    ### Logging

    # If this is &quot;on&quot;, Akka will log all inbound messages at DEBUG level,
    # if off then they are not logged
    log-received-messages = off

    # If this is &quot;on&quot;, Akka will log all outbound messages at DEBUG level,
    # if off then they are not logged
    log-sent-messages = off

    # Sets the log granularity level at which Akka logs remoting events. This setting
    # can take the values OFF, ERROR, WARNING, INFO, DEBUG, or ON. For compatibility
    # reasons the setting &quot;on&quot; will default to &quot;debug&quot; level. Please note that the effective
    # logging level is still determined by the global logging level of the actor system:
    # for example debug level remoting events will be only logged if the system
    # is running with debug level logging.
    # Failures to deserialize received messages also fall under this flag.
    log-remote-lifecycle-events = on

    # Logging of message types with payload size in bytes larger than
    # this value. Maximum detected size per message type is logged once,
    # with an increase threshold of 10%.
    # By default this feature is turned off. Activate it by setting the property to
    # a value in bytes, such as 1000b. Note that for all messages larger than this
    # limit there will be extra performance and scalability cost.
    log-frame-size-exceeding = off
    
    # Log warning if the number of messages in the backoff buffer in the endpoint
    # writer exceeds this limit. It can be disabled by setting the value to off.
    log-buffer-size-exceeding = 50000

    ### Failure detection and recovery

    # Settings for the failure detector to monitor connections.
    # For TCP it is not important to have fast failure detection, since
    # most connection failures are captured by TCP itself. 
    transport-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.DeadlineFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 4 s

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # A margin to the `heartbeat-interval` is important to be able to survive sudden,
      # occasional, pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 20 s
    }

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used for remote death watch.
    watch-failure-detector {

      # FQCN of the failure detector implementation.
      # It must implement akka.remote.FailureDetector and have
      # a public constructor with a com.typesafe.config.Config and
      # akka.actor.EventStream parameter.
      implementation-class = &quot;akka.remote.PhiAccrualFailureDetector&quot;

      # How often keep-alive heartbeat messages should be sent to each connection.
      heartbeat-interval = 1 s

      # Defines the failure detector threshold.
      # A low threshold is prone to generate many wrong suspicions but ensures
      # a quick detection in the event of a real crash. Conversely, a high
      # threshold generates fewer mistakes but needs more time to detect
      # actual crashes.
      threshold = 10.0

      # Number of the samples of inter-heartbeat arrival times to adaptively
      # calculate the failure timeout for connections.
      max-sample-size = 200

      # Minimum standard deviation to use for the normal distribution in
      # AccrualFailureDetector. Too low standard deviation might result in
      # too much sensitivity for sudden, but normal, deviations in heartbeat
      # inter arrival times.
      min-std-deviation = 100 ms

      # Number of potentially lost/delayed heartbeats that will be
      # accepted before considering it to be an anomaly.
      # This margin is important to be able to survive sudden, occasional,
      # pauses in heartbeat arrivals, due to for example garbage collect or
      # network drop.
      acceptable-heartbeat-pause = 10 s


      # How often to check for nodes marked as unreachable by the failure
      # detector
      unreachable-nodes-reaper-interval = 1s

      # After the heartbeat request has been sent the first failure detection
      # will start after this period, even though no heartbeat mesage has
      # been received.
      expected-response-after = 3 s

    }

    # After failed to establish an outbound connection, the remoting will mark the
    # address as failed. This configuration option controls how much time should
    # be elapsed before reattempting a new connection. While the address is
    # gated, all messages sent to the address are delivered to dead-letters.
    # Since this setting limits the rate of reconnects setting it to a
    # very short interval (i.e. less than a second) may result in a storm of
    # reconnect attempts.
    retry-gate-closed-for = 5 s

    # After catastrophic communication failures that result in the loss of system
    # messages or after the remote DeathWatch triggers the remote system gets
    # quarantined to prevent inconsistent behavior.
    # This setting controls how long the Quarantine marker will be kept around
    # before being removed to avoid long-term memory leaks.
    # WARNING: DO NOT change this to a small value to re-enable communication with
    # quarantined nodes. Such feature is not supported and any behavior between
    # the affected systems after lifting the quarantine is undefined.
    prune-quarantine-marker-after = 5 d

    # If system messages have been exchanged between two systems (i.e. remote death
    # watch or remote deployment has been used) a remote system will be marked as
    # quarantined after the two system has no active association, and no
    # communication happens during the time configured here.
    # The only purpose of this setting is to avoid storing system message redelivery
    # data (sequence number state, etc.) for an undefined amount of time leading to long
    # term memory leak. Instead, if a system has been gone for this period,
    # or more exactly
    # - there is no association between the two systems (TCP connection, if TCP transport is used)
    # - neither side has been attempting to communicate with the other
    # - there are no pending system messages to deliver
    # for the amount of time configured here, the remote system will be quarantined and all state
    # associated with it will be dropped.
    quarantine-after-silence = 5 d

    # This setting defines the maximum number of unacknowledged system messages
    # allowed for a remote system. If this limit is reached the remote system is
    # declared to be dead and its UID marked as tainted.
    system-message-buffer-size = 20000

    # This setting defines the maximum idle time after an individual
    # acknowledgement for system messages is sent. System message delivery
    # is guaranteed by explicit acknowledgement messages. These acks are
    # piggybacked on ordinary traffic messages. If no traffic is detected
    # during the time period configured here, the remoting will send out
    # an individual ack.
    system-message-ack-piggyback-timeout = 0.3 s

    # This setting defines the time after internal management signals
    # between actors (used for DeathWatch and supervision) that have not been
    # explicitly acknowledged or negatively acknowledged are resent.
    # Messages that were negatively acknowledged are always immediately
    # resent.
    resend-interval = 2 s
    
    # Maximum number of unacknowledged system messages that will be resent
    # each &#39;resend-interval&#39;. If you watch many (&gt; 1000) remote actors you can
    # increase this value to for example 600, but a too large limit (e.g. 10000)
    # may flood the connection and might cause false failure detection to trigger.
    # Test such a configuration by watching all actors at the same time and stop
    # all watched actors at the same time.
    resend-limit = 200

    # WARNING: this setting should not be not changed unless all of its consequences
    # are properly understood which assumes experience with remoting internals
    # or expert advice.
    # This setting defines the time after redelivery attempts of internal management
    # signals are stopped to a remote system that has been not confirmed to be alive by
    # this system before.
    initial-system-message-delivery-timeout = 3 m

    ### Transports and adapters

    # List of the transport drivers that will be loaded by the remoting.
    # A list of fully qualified config paths must be provided where
    # the given configuration path contains a transport-class key
    # pointing to an implementation class of the Transport interface.
    # If multiple transports are provided, the address of the first
    # one will be used as a default address.
    enabled-transports = [&quot;akka.remote.netty.tcp&quot;]

    # Transport drivers can be augmented with adapters by adding their
    # name to the applied-adapters setting in the configuration of a
    # transport. The available adapters should be configured in this
    # section by providing a name, and the fully qualified name of
    # their corresponding implementation. The class given here
    # must implement akka.akka.remote.transport.TransportAdapterProvider
    # and have public constructor without parameters.
    adapters {
      gremlin = &quot;akka.remote.transport.FailureInjectorProvider&quot;
      trttl = &quot;akka.remote.transport.ThrottlerProvider&quot;
    }

    ### Default configuration for the Netty based transport drivers

    netty.tcp {
      # The class given here must implement the akka.remote.transport.Transport
      # interface and offer a public constructor which takes two arguments:
      #  1) akka.actor.ExtendedActorSystem
      #  2) com.typesafe.config.Config
      transport-class = &quot;akka.remote.transport.netty.NettyTransport&quot;

      # Transport drivers can be augmented with adapters by adding their
      # name to the applied-adapters list. The last adapter in the
      # list is the adapter immediately above the driver, while
      # the first one is the top of the stack below the standard
      # Akka protocol
      applied-adapters = []

      transport-protocol = tcp

      # The default remote server port clients should connect to.
      # Default is 2552 (AKKA), use 0 if you want a random available port
      # This port needs to be unique for each actor system on the same machine.
      port = 2552

      # The hostname or ip to bind the remoting to,
      # InetAddress.getLocalHost.getHostAddress is used if empty
      hostname = &quot;&quot;

      # Enables SSL support on this transport
      enable-ssl = false

      # Sets the connectTimeoutMillis of all outbound connections,
      # i.e. how long a connect may take until it is timed out
      connection-timeout = 15 s

      # If set to &quot;&lt;id.of.dispatcher&gt;&quot; then the specified dispatcher
      # will be used to accept inbound connections, and perform IO. If &quot;&quot; then
      # dedicated threads will be used.
      # Please note that the Netty driver only uses this configuration and does
      # not read the &quot;akka.remote.use-dispatcher&quot; entry. Instead it has to be
      # configured manually to point to the same dispatcher if needed.
      use-dispatcher-for-io = &quot;&quot;

      # Sets the high water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-high-water-mark = 0b

      # Sets the low water mark for the in and outbound sockets,
      # set to 0b for platform default
      write-buffer-low-water-mark = 0b

      # Sets the send buffer size of the Sockets,
      # set to 0b for platform default
      send-buffer-size = 256000b

      # Sets the receive buffer size of the Sockets,
      # set to 0b for platform default
      receive-buffer-size = 256000b

      # Maximum message size the transport will accept, but at least
      # 32000 bytes.
      # Please note that UDP does not support arbitrary large datagrams,
      # so this setting has to be chosen carefully when using UDP.
      # Both send-buffer-size and receive-buffer-size settings has to
      # be adjusted to be able to buffer messages of maximum size.
      maximum-frame-size = 128000b

      # Sets the size of the connection backlog
      backlog = 4096

      # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
      tcp-nodelay = on

      # Enables TCP Keepalive, subject to the O/S kernel’s configuration
      tcp-keepalive = on

      # Enables SO_REUSEADDR, which determines when an ActorSystem can open
      # the specified listen port (the meaning differs between *nix and Windows)
      # Valid values are &quot;on&quot;, &quot;off&quot; and &quot;off-for-windows&quot;
      # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
      # &quot;off-for-windows&quot; of course means that it&#39;s &quot;on&quot; for all other platforms
      tcp-reuse-addr = off-for-windows

      # Used to configure the number of I/O worker threads on server sockets
      server-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }

      # Used to configure the number of I/O worker threads on client sockets
      client-socket-worker-pool {
        # Min number of threads to cap factor-based number to
        pool-size-min = 2

        # The pool size factor is used to determine thread pool size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the pool-size-min and
        # pool-size-max values.
        pool-size-factor = 1.0

        # Max number of threads to cap factor-based number to
        pool-size-max = 2
      }


    }

    netty.udp = ${akka.remote.netty.tcp}
    netty.udp {
      transport-protocol = udp
    }

    netty.ssl = ${akka.remote.netty.tcp}
    netty.ssl = {
      # Enable SSL/TLS encryption.
      # This must be enabled on both the client and server to work.
      enable-ssl = true

      security {
        # This is the Java Key Store used by the server connection
        key-store = &quot;keystore&quot;

        # This password is used for decrypting the key store
        key-store-password = &quot;changeme&quot;

        # This password is used for decrypting the key
        key-password = &quot;changeme&quot;

        # This is the Java Key Store used by the client connection
        trust-store = &quot;truststore&quot;

        # This password is used for decrypting the trust store
        trust-store-password = &quot;changeme&quot;

        # Protocol to use for SSL encryption, choose from:
        # Java 6 &amp; 7:
        #   &#39;SSLv3&#39;, &#39;TLSv1&#39;
        # Java 7:
        #   &#39;TLSv1.1&#39;, &#39;TLSv1.2&#39;
        protocol = &quot;TLSv1&quot;

        # Example: [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;, &quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;]
        # You need to install the JCE Unlimited Strength Jurisdiction Policy
        # Files to use AES 256.
        # More info here:
        # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
        enabled-algorithms = [&quot;TLS_RSA_WITH_AES_128_CBC_SHA&quot;]

        # There are three options, in increasing order of security:
        # &quot;&quot; or SecureRandom =&gt; (default)
        # &quot;SHA1PRNG&quot; =&gt; Can be slow because of blocking issues on Linux
        # &quot;AES128CounterSecureRNG&quot; =&gt; fastest startup and based on AES encryption
        # algorithm
        # &quot;AES256CounterSecureRNG&quot;
        # The following use one of 3 possible seed sources, depending on
        # availability: /dev/random, random.org and SecureRandom (provided by Java)
        # &quot;AES128CounterInetRNG&quot;
        # &quot;AES256CounterInetRNG&quot; (Install JCE Unlimited Strength Jurisdiction
        # Policy Files first)
        # Setting a value here may require you to supply the appropriate cipher
        # suite (see enabled-algorithms section above)
        random-number-generator = &quot;&quot;
      }
    }

    ### Default configuration for the failure injector transport adapter

    gremlin {
      # Enable debug logging of the failure injector transport adapter
      debug = off
    }

    ### Default dispatcher for the remoting subsystem

    default-remote-dispatcher {
      type = Dispatcher
      executor = &quot;fork-join-executor&quot;
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 2
        parallelism-max = 2
      }
    }
    
    backoff-remote-dispatcher {
      type = Dispatcher
      executor = &quot;fork-join-executor&quot;
      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 2
        parallelism-max = 2
      }
    }


  }

}
</pre></div>
</div>
</div>
<div class="section" id="akka-testkit">
<span id="config-akka-testkit"></span><h3>akka-testkit</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>######################################
# Akka Testkit Reference Config File #
######################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {
  test {
    # factor by which to scale timeouts during tests, e.g. to account for shared
    # build system load
    timefactor =  1.0

    # duration of EventFilter.intercept waits after the block is finished until
    # all required messages are received
    filter-leeway = 3s

    # duration to wait in expectMsg and friends outside of within() block
    # by default
    single-expect-default = 3s

    # The timeout that is added as an implicit by DefaultTimeout trait
    default-timeout = 5s

    calling-thread-dispatcher {
      type = akka.testkit.CallingThreadDispatcherConfigurator
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="akka-zeromq">
<span id="config-akka-zeromq"></span><h3>akka-zeromq</h3>
<div class="highlight-none"><div class="highlight"><pre><span></span>#####################################
# Akka ZeroMQ Reference Config File #
#####################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

akka {

  zeromq {

    # The default timeout for a poll on the actual zeromq socket.
    poll-timeout = 100ms

    # Timeout for creating a new socket
    new-socket-timeout = 5s

    socket-dispatcher {
      # A zeromq socket needs to be pinned to the thread that created it.
      # Changing this value results in weird errors and race conditions within
      # zeromq
      executor = thread-pool-executor
      type = &quot;PinnedDispatcher&quot;
      thread-pool-executor.allow-core-timeout = off
    }
  }
}
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.typesafe.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2014 <a href="http://www.typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Apr 01, 2016
    </p>          
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // change hash when TOC link clicked:
  $toc.find("a").click(function() { window.location.hash = $(this).attr('href'); });

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>
  

  </body>
</html>