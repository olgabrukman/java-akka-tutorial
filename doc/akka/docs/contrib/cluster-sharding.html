

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cluster Sharding &mdash; Akka Documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify.css" type="text/css" />
    <link rel="stylesheet" href="../_static/base.css" type="text/css" />
    <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3.15',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/toc.js"></script>
    <script type="text/javascript" src="../_static/prettify.js"></script>
    <script type="text/javascript" src="../_static/highlightCode.js"></script>
    <script type="text/javascript" src="../_static/effects.core.js"></script>
    <script type="text/javascript" src="../_static/effects.highlight.js"></script>
    <script type="text/javascript" src="../_static/scrollTo.js"></script>
    <script type="text/javascript" src="../_static/contentsFix.js"></script>
    <script type="text/javascript" src="../_static/ga.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Akka Documentation" href="../index.html" />
    <link rel="up" title="External Contributions" href="index.html" />
    <link rel="next" title="Distributed Publish Subscribe in Cluster" href="distributed-pub-sub.html" />
    <link rel="prev" title="Cluster Singleton" href="cluster-singleton.html" />

  </head>
  <body role="document">
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <div class="navbar-logo">
          <a href="http://akka.io"><img class="svg-logo" src="../_static/akka_full_color.svg" /></a>
        </div>    
        <ul class="nav">
          <li><a href="http://akka.io/docs">Documentation</a></li>
          <li><a href="http://akka.io/faq">FAQ</a></li>
          <li><a href="http://akka.io/downloads">Download</a></li>
          <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>
          <li><a href="http://github.com/akka/akka">Code</a></li>           
          <li><a href="http://www.typesafe.com/how/subscription">Commercial Support</a></li>
        </ul>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="container">
      <div class="page-title">Cluster Sharding</div>
      <div class="pdf-link"><a href="../AkkaScala.pdf" title="Akka Scala Documentation"><img src="../_static/pdf-scala-icon.png" style="height: 40px;" /></a></div>
      <div class="pdf-link"><a href="../AkkaJava.pdf" title="Akka Java Documentation"><img src="../_static/pdf-java-icon.png" style="height: 40px;" /></a></div>
    </div>
    <div class="main-container">
      <div class="container">
        <div class="row">
          <div class="span12">
            <ul class="breadcrumb">           
              <li>
                 <span class="divider">|</span> <a href="distributed-pub-sub.html">Distributed Publish Subscribe in Cluster</a> <span class="divider">»</span>
              </li>
              <li>
                <a href="../index.html">Contents</a>
              </li>
              <li>
                <span class="divider">«</span> <a href="cluster-singleton.html">Cluster Singleton</a> <span class="divider">|</span>
              </li>
              <li>
                Version 2.3.15
              </li>
            </ul>
          </div>
        </div>
        <div class="row"><div class="span9">
            
  <div class="section" id="cluster-sharding">
<span id="id1"></span><h1>Cluster Sharding</h1>
<p>Cluster sharding is useful when you need to distribute actors across several nodes in the cluster and want to
be able to interact with them using their logical identifier, but without having to care about
their physical location in the cluster, which might also change over time.</p>
<p>It could for example be actors representing Aggregate Roots in Domain-Driven Design terminology.
Here we call these actors &quot;entries&quot;. These actors typically have persistent (durable) state,
but this feature is not limited to actors with persistent state.</p>
<p>Cluster sharding is typically used when you have many stateful actors that together consume
more resources (e.g. memory) than fit on one machine. If you only have a few stateful actors
it might be easier to run them on a <a class="reference internal" href="cluster-singleton.html#cluster-singleton"><span>Cluster Singleton</span></a> node.</p>
<p>In this context sharding means that actors with an identifier, so called entries,
can be automatically distributed across multiple nodes in the cluster. Each entry
actor runs only at one place, and messages can be sent to the entry without requiring
the sender() to know the location of the destination actor. This is achieved by sending
the messages via a <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor provided by this extension, which knows how
to route the message with the entry id to the final destination.</p>
<div class="section" id="an-example-in-java">
<h2>An Example in Java</h2>
<p>This is how an entry actor may look like:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Counter</span> <span class="k">extends</span> <span class="nc">UntypedPersistentActor</span> <span class="o">{</span>

  <span class="n">public</span> <span class="n">static</span> <span class="n">enum</span> <span class="nc">CounterOp</span> <span class="o">{</span>
    <span class="nc">INCREMENT</span><span class="o">,</span> <span class="nc">DECREMENT</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">Get</span> <span class="o">{</span>
    <span class="k">final</span> <span class="n">public</span> <span class="n">long</span> <span class="n">counterId</span><span class="o">;</span>

    <span class="n">public</span> <span class="nc">Get</span><span class="o">(</span><span class="n">long</span> <span class="n">counterId</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="n">counterId</span> <span class="k">=</span> <span class="n">counterId</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">EntryEnvelope</span> <span class="o">{</span>
    <span class="k">final</span> <span class="n">public</span> <span class="n">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="k">final</span> <span class="n">public</span> <span class="nc">Object</span> <span class="n">payload</span><span class="o">;</span>

    <span class="n">public</span> <span class="nc">EntryEnvelope</span><span class="o">(</span><span class="n">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">payload</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="n">id</span> <span class="k">=</span> <span class="n">id</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">payload</span> <span class="k">=</span> <span class="n">payload</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">public</span> <span class="n">static</span> <span class="k">class</span> <span class="nc">CounterChanged</span> <span class="o">{</span>
    <span class="k">final</span> <span class="n">public</span> <span class="n">int</span> <span class="n">delta</span><span class="o">;</span>

    <span class="n">public</span> <span class="nc">CounterChanged</span><span class="o">(</span><span class="n">int</span> <span class="n">delta</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="n">delta</span> <span class="k">=</span> <span class="n">delta</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">int</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>
  
  <span class="c1">// getSelf().path().parent().name() is the type name (utf-8 URL-encoded) </span>
  <span class="c1">// getSelf().path().name() is the entry identifier (utf-8 URL-encoded)</span>
  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">String</span> <span class="n">persistenceId</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getSelf</span><span class="o">().</span><span class="n">path</span><span class="o">().</span><span class="n">parent</span><span class="o">().</span><span class="n">name</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">getSelf</span><span class="o">().</span><span class="n">path</span><span class="o">().</span><span class="n">name</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">preStart</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">super</span><span class="o">.</span><span class="n">preStart</span><span class="o">();</span>
    <span class="n">context</span><span class="o">().</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="nc">SECONDS</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="n">void</span> <span class="n">updateState</span><span class="o">(</span><span class="nc">CounterChanged</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">event</span><span class="o">.</span><span class="n">delta</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceiveRecover</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">CounterChanged</span><span class="o">)</span>
      <span class="n">updateState</span><span class="o">((</span><span class="nc">CounterChanged</span><span class="o">)</span> <span class="n">msg</span><span class="o">);</span>
    <span class="k">else</span>
      <span class="n">unhandled</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">onReceiveCommand</span><span class="o">(</span><span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="n">instanceof</span> <span class="nc">Get</span><span class="o">)</span>
      <span class="n">getSender</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">getSelf</span><span class="o">());</span>

    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nc">CounterOp</span><span class="o">.</span><span class="nc">INCREMENT</span><span class="o">)</span>
      <span class="n">persist</span><span class="o">(</span><span class="k">new</span> <span class="nc">CounterChanged</span><span class="o">(+</span><span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">CounterChanged</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">CounterChanged</span> <span class="n">evt</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">});</span>

    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">==</span> <span class="nc">CounterOp</span><span class="o">.</span><span class="nc">DECREMENT</span><span class="o">)</span>
      <span class="n">persist</span><span class="o">(</span><span class="k">new</span> <span class="nc">CounterChanged</span><span class="o">(-</span><span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Procedure</span><span class="o">&lt;</span><span class="nc">CounterChanged</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="n">public</span> <span class="n">void</span> <span class="n">apply</span><span class="o">(</span><span class="nc">CounterChanged</span> <span class="n">evt</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">});</span>

    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="nc">ReceiveTimeout</span><span class="o">.</span><span class="n">getInstance</span><span class="o">()))</span>
      <span class="n">getContext</span><span class="o">().</span><span class="n">parent</span><span class="o">().</span><span class="n">tell</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">ShardRegion</span><span class="o">.</span><span class="nc">Passivate</span><span class="o">(</span><span class="nc">PoisonPill</span><span class="o">.</span><span class="n">getInstance</span><span class="o">()),</span> <span class="n">getSelf</span><span class="o">());</span>

    <span class="k">else</span>
      <span class="n">unhandled</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The above actor uses event sourcing and the support provided in <code class="docutils literal"><span class="pre">UntypedPersistentActor</span></code> to store its state.
It does not have to be a persistent actor, but in case of failure or migration of entries between nodes it must be able to recover
its state if it is valuable.</p>
<p>Note how the <code class="docutils literal"><span class="pre">persistenceId</span></code> is defined. You may define it another way, but it must be unique.</p>
<p>When using the sharding extension you are first, typically at system startup on each node
in the cluster, supposed to register the supported entry types with the <code class="docutils literal"><span class="pre">ClusterSharding.start</span></code>
method. <code class="docutils literal"><span class="pre">ClusterSharding.start</span></code> gives you the reference which you can pass along.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">ActorRef</span> <span class="n">startedCounterRegion</span> <span class="k">=</span> <span class="nc">ClusterSharding</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">start</span><span class="o">(</span><span class="s">&quot;Counter&quot;</span><span class="o">,</span> <span class="nc">Props</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="n">class</span><span class="o">),</span>
          <span class="n">messageExtractor</span><span class="o">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">messageExtractor</span></code> defines application specific methods to extract the entry
identifier and the shard identifier from incoming messages.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">ShardRegion</span><span class="o">.</span><span class="nc">MessageExtractor</span> <span class="n">messageExtractor</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShardRegion</span><span class="o">.</span><span class="nc">MessageExtractor</span><span class="o">()</span> <span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">String</span> <span class="n">entryId</span><span class="o">(</span><span class="nc">Object</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span>
      <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="n">valueOf</span><span class="o">(((</span><span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span> <span class="n">message</span><span class="o">).</span><span class="n">id</span><span class="o">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">)</span>
      <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="n">valueOf</span><span class="o">(((</span><span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">)</span> <span class="n">message</span><span class="o">).</span><span class="n">counterId</span><span class="o">);</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">Object</span> <span class="n">entryMessage</span><span class="o">(</span><span class="nc">Object</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span>
      <span class="k">return</span> <span class="o">((</span><span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span> <span class="n">message</span><span class="o">).</span><span class="n">payload</span><span class="o">;</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="n">public</span> <span class="nc">String</span> <span class="n">shardId</span><span class="o">(</span><span class="nc">Object</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">long</span> <span class="n">id</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">)</span> <span class="n">message</span><span class="o">).</span><span class="n">id</span><span class="o">;</span>
      <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="n">valueOf</span><span class="o">(</span><span class="n">id</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="n">instanceof</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">long</span> <span class="n">id</span> <span class="k">=</span> <span class="o">((</span><span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">)</span> <span class="n">message</span><span class="o">).</span><span class="n">counterId</span><span class="o">;</span>
      <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="n">valueOf</span><span class="o">(</span><span class="n">id</span> <span class="o">%</span> <span class="mi">10</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">};</span>
</pre></div>
</div>
<p>This example illustrates two different ways to define the entry identifier in the messages:</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal"><span class="pre">Get</span></code> message includes the identifier itself.</li>
<li>The <code class="docutils literal"><span class="pre">EntryEnvelope</span></code> holds the identifier, and the actual message that is
sent to the entry actor is wrapped in the envelope.</li>
</ul>
</div></blockquote>
<p>Note how these two messages types are handled in the <code class="docutils literal"><span class="pre">entryId</span></code> and <code class="docutils literal"><span class="pre">entryMessage</span></code> methods shown above.</p>
<p>A shard is a group of entries that will be managed together. The grouping is defined by the
<code class="docutils literal"><span class="pre">shardResolver</span></code> function shown above. Creating a good sharding algorithm is an interesting challenge
in itself. Try to produce a uniform distribution, i.e. same amount of entries in each shard.
As a rule of thumb, the number of shards should be a factor ten greater than the planned maximum number
of cluster nodes.</p>
<p>Messages to the entries are always sent via the local <code class="docutils literal"><span class="pre">ShardRegion</span></code>. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor for a
named entry type can be retrieved with <code class="docutils literal"><span class="pre">ClusterSharding.shardRegion</span></code>. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> will
lookup the location of the shard for the entry if it does not already know its location. It will
delegate the message to the right node and it will create the entry actor on demand, i.e. when the
first message for a specific entry is delivered.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">ActorRef</span> <span class="n">counterRegion</span> <span class="k">=</span> <span class="nc">ClusterSharding</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">shardRegion</span><span class="o">(</span><span class="s">&quot;Counter&quot;</span><span class="o">);</span>
<span class="n">counterRegion</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>

<span class="n">counterRegion</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">EntryEnvelope</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span>
    <span class="nc">Counter</span><span class="o">.</span><span class="nc">CounterOp</span><span class="o">.</span><span class="nc">INCREMENT</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
<span class="n">counterRegion</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="k">new</span> <span class="nc">Counter</span><span class="o">.</span><span class="nc">Get</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
</pre></div>
</div>
</div>
<div class="section" id="an-example-in-scala">
<h2>An Example in Scala</h2>
<p>This is how an entry actor may look like:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">object</span> <span class="nc">Increment</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Decrement</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Get</span><span class="o">(</span><span class="n">counterId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">EntryEnvelope</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">payload</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Stop</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">CounterChanged</span><span class="o">(</span><span class="n">delta</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Counter</span> <span class="k">extends</span> <span class="nc">PersistentActor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">ShardRegion.Passivate</span>

  <span class="n">context</span><span class="o">.</span><span class="n">setReceiveTimeout</span><span class="o">(</span><span class="mf">120.</span><span class="n">seconds</span><span class="o">)</span>

  <span class="c1">// self.path.parent.name is the type name (utf-8 URL-encoded)</span>
  <span class="c1">// self.path.name is the entry identifier (utf-8 URL-encoded)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">persistenceId</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">name</span>

  <span class="k">var</span> <span class="n">count</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">updateState</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">CounterChanged</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">event</span><span class="o">.</span><span class="n">delta</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveRecover</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">evt</span><span class="k">:</span> <span class="kt">CounterChanged</span> <span class="o">⇒</span> <span class="n">updateState</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receiveCommand</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Increment</span>      <span class="k">⇒</span> <span class="n">persist</span><span class="o">(</span><span class="nc">CounterChanged</span><span class="o">(+</span><span class="mi">1</span><span class="o">))(</span><span class="n">updateState</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Decrement</span>      <span class="k">⇒</span> <span class="n">persist</span><span class="o">(</span><span class="nc">CounterChanged</span><span class="o">(-</span><span class="mi">1</span><span class="o">))(</span><span class="n">updateState</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>         <span class="k">⇒</span> <span class="n">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">count</span>
    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">⇒</span> <span class="n">context</span><span class="o">.</span><span class="n">parent</span> <span class="o">!</span> <span class="nc">Passivate</span><span class="o">(</span><span class="n">stopMessage</span> <span class="k">=</span> <span class="nc">Stop</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Stop</span>           <span class="k">⇒</span> <span class="n">context</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The above actor uses event sourcing and the support provided in <code class="docutils literal"><span class="pre">PersistentActor</span></code> to store its state.
It does not have to be a persistent actor, but in case of failure or migration of entries between nodes it must be able to recover
its state if it is valuable.</p>
<p>Note how the <code class="docutils literal"><span class="pre">persistenceId</span></code> is defined. You may define it another way, but it must be unique.</p>
<p>When using the sharding extension you are first, typically at system startup on each node
in the cluster, supposed to register the supported entry types with the <code class="docutils literal"><span class="pre">ClusterSharding.start</span></code>
method. <code class="docutils literal"><span class="pre">ClusterSharding.start</span></code> gives you the reference which you can pass along.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">counterRegion</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="nc">ClusterSharding</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">start</span><span class="o">(</span>
  <span class="n">typeName</span> <span class="k">=</span> <span class="s">&quot;Counter&quot;</span><span class="o">,</span>
  <span class="n">entryProps</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Counter</span><span class="o">]),</span>
  <span class="n">idExtractor</span> <span class="k">=</span> <span class="n">idExtractor</span><span class="o">,</span>
  <span class="n">shardResolver</span> <span class="k">=</span> <span class="n">shardResolver</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">idExtractor</span></code> and <code class="docutils literal"><span class="pre">shardResolver</span></code> are two application specific functions to extract the entry
identifier and the shard identifier from incoming messages.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">idExtractor</span><span class="k">:</span> <span class="kt">ShardRegion.IdExtractor</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EntryEnvelope</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">payload</span><span class="o">)</span> <span class="k">⇒</span> <span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">payload</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">msg</span> <span class="k">@</span> <span class="nc">Get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>              <span class="k">⇒</span> <span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">msg</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">shardResolver</span><span class="k">:</span> <span class="kt">ShardRegion.ShardResolver</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EntryEnvelope</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">⇒</span> <span class="o">(</span><span class="n">id</span> <span class="o">%</span> <span class="mi">12</span><span class="o">).</span><span class="n">toString</span>
  <span class="k">case</span> <span class="nc">Get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>              <span class="k">⇒</span> <span class="o">(</span><span class="n">id</span> <span class="o">%</span> <span class="mi">12</span><span class="o">).</span><span class="n">toString</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This example illustrates two different ways to define the entry identifier in the messages:</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal"><span class="pre">Get</span></code> message includes the identifier itself.</li>
<li>The <code class="docutils literal"><span class="pre">EntryEnvelope</span></code> holds the identifier, and the actual message that is
sent to the entry actor is wrapped in the envelope.</li>
</ul>
</div></blockquote>
<p>Note how these two messages types are handled in the <code class="docutils literal"><span class="pre">idExtractor</span></code> function shown above.</p>
<p>A shard is a group of entries that will be managed together. The grouping is defined by the
<code class="docutils literal"><span class="pre">shardResolver</span></code> function shown above. Creating a good sharding algorithm is an interesting challenge
in itself. Try to produce a uniform distribution, i.e. same amount of entries in each shard.
As a rule of thumb, the number of shards should be a factor ten greater than the planned maximum number
of cluster nodes.</p>
<p>Messages to the entries are always sent via the local <code class="docutils literal"><span class="pre">ShardRegion</span></code>. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor for a
named entry type can be retrieved with <code class="docutils literal"><span class="pre">ClusterSharding.shardRegion</span></code>. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> will
lookup the location of the shard for the entry if it does not already know its location. It will
delegate the message to the right node and it will create the entry actor on demand, i.e. when the
first message for a specific entry is delivered.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">counterRegion</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="nc">ClusterSharding</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">shardRegion</span><span class="o">(</span><span class="s">&quot;Counter&quot;</span><span class="o">)</span>
<span class="n">counterRegion</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
<span class="n">expectMsg</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="n">counterRegion</span> <span class="o">!</span> <span class="nc">EntryEnvelope</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="nc">Increment</span><span class="o">)</span>
<span class="n">counterRegion</span> <span class="o">!</span> <span class="nc">Get</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
<span class="n">expectMsg</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>A more comprehensive sample is available in the <a class="reference external" href="http://www.typesafe.com/platform/getstarted">Typesafe Activator</a>
tutorial named <a class="reference external" href="http://www.typesafe.com/activator/template/akka-cluster-sharding-scala">Akka Cluster Sharding with Scala!</a>.</p>
</div>
<div class="section" id="how-it-works">
<h2>How it works</h2>
<p>The <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor is started on each node in the cluster, or group of nodes
tagged with a specific role. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> is created with two application specific
functions to extract the entry identifier and the shard identifier from incoming messages.
A shard is a group of entries that will be managed together. For the first message in a
specific shard the <code class="docutils literal"><span class="pre">ShardRegion</span></code> request the location of the shard from a central coordinator,
the <code class="docutils literal"><span class="pre">ShardCoordinator</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">ShardCoordinator</span></code> decides which <code class="docutils literal"><span class="pre">ShardRegion</span></code> that
owns the shard. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> receives the decided home of the shard
and if that is the <code class="docutils literal"><span class="pre">ShardRegion</span></code> instance itself it will create a local child
actor representing the entry and direct all messages for that entry to it.
If the shard home is another <code class="docutils literal"><span class="pre">ShardRegion</span></code> instance messages will be forwarded
to that <code class="docutils literal"><span class="pre">ShardRegion</span></code> instance instead. While resolving the location of a
shard incoming messages for that shard are buffered and later delivered when the
shard home is known. Subsequent messages to the resolved shard can be delivered
to the target destination immediately without involving the <code class="docutils literal"><span class="pre">ShardCoordinator</span></code>.</p>
<p>Scenario 1:</p>
<ol class="arabic simple">
<li>Incoming message M1 to <code class="docutils literal"><span class="pre">ShardRegion</span></code> instance R1.</li>
<li>M1 is mapped to shard S1. R1 doesn't know about S1, so it asks the coordinator C for the location of S1.</li>
<li>C answers that the home of S1 is R1.</li>
<li>R1 creates child actor for the entry E1 and sends buffered messages for S1 to E1 child</li>
<li>All incoming messages for S1 which arrive at R1 can be handled by R1 without C. It creates entry children as needed, and forwards messages to them.</li>
</ol>
<p>Scenario 2:</p>
<ol class="arabic simple">
<li>Incoming message M2 to R1.</li>
<li>M2 is mapped to S2. R1 doesn't know about S2, so it asks C for the location of S2.</li>
<li>C answers that the home of S2 is R2.</li>
<li>R1 sends buffered messages for S2 to R2</li>
<li>All incoming messages for S2 which arrive at R1 can be handled by R1 without C. It forwards messages to R2.</li>
<li>R2 receives message for S2, ask C, which answers that the home of S2 is R2, and we are in Scenario 1 (but for R2).</li>
</ol>
<p>To make sure that at most one instance of a specific entry actor is running somewhere
in the cluster it is important that all nodes have the same view of where the shards
are located. Therefore the shard allocation decisions are taken by the central
<code class="docutils literal"><span class="pre">ShardCoordinator</span></code>, which is running as a cluster singleton, i.e. one instance on
the oldest member among all cluster nodes or a group of nodes tagged with a specific
role.</p>
<p>The logic that decides where a shard is to be located is defined in a pluggable shard
allocation strategy. The default implementation <code class="docutils literal"><span class="pre">ShardCoordinator.LeastShardAllocationStrategy</span></code>
allocates new shards to the <code class="docutils literal"><span class="pre">ShardRegion</span></code> with least number of previously allocated shards.
This strategy can be replaced by an application specific implementation.</p>
<p>To be able to use newly added members in the cluster the coordinator facilitates rebalancing
of shards, i.e. migrate entries from one node to another. In the rebalance process the
coordinator first notifies all <code class="docutils literal"><span class="pre">ShardRegion</span></code> actors that a handoff for a shard has started.
That means they will start buffering incoming messages for that shard, in the same way as if the
shard location is unknown. During the rebalance process the coordinator will not answer any
requests for the location of shards that are being rebalanced, i.e. local buffering will
continue until the handoff is completed. The <code class="docutils literal"><span class="pre">ShardRegion</span></code> responsible for the rebalanced shard
will stop all entries in that shard by sending <code class="docutils literal"><span class="pre">PoisonPill</span></code> to them. When all entries have
been terminated the <code class="docutils literal"><span class="pre">ShardRegion</span></code> owning the entries will acknowledge the handoff as completed
to the coordinator. Thereafter the coordinator will reply to requests for the location of
the shard and thereby allocate a new home for the shard and then buffered messages in the
<code class="docutils literal"><span class="pre">ShardRegion</span></code> actors are delivered to the new location. This means that the state of the entries
are not transferred or migrated. If the state of the entries are of importance it should be
persistent (durable), e.g. with <code class="docutils literal"><span class="pre">akka-persistence</span></code>, so that it can be recovered at the new
location.</p>
<p>The logic that decides which shards to rebalance is defined in a pluggable shard
allocation strategy. The default implementation <code class="docutils literal"><span class="pre">ShardCoordinator.LeastShardAllocationStrategy</span></code>
picks shards for handoff from the <code class="docutils literal"><span class="pre">ShardRegion</span></code> with most number of previously allocated shards.
They will then be allocated to the <code class="docutils literal"><span class="pre">ShardRegion</span></code> with least number of previously allocated shards,
i.e. new members in the cluster. There is a configurable threshold of how large the difference
must be to begin the rebalancing. This strategy can be replaced by an application specific
implementation.</p>
<p>The state of shard locations in the <code class="docutils literal"><span class="pre">ShardCoordinator</span></code> is persistent (durable) with
<code class="docutils literal"><span class="pre">akka-persistence</span></code> to survive failures. Since it is running in a cluster <code class="docutils literal"><span class="pre">akka-persistence</span></code>
must be configured with a distributed journal. When a crashed or unreachable coordinator
node has been removed (via down) from the cluster a new <code class="docutils literal"><span class="pre">ShardCoordinator</span></code> singleton
actor will take over and the state is recovered. During such a failure period shards
with known location are still available, while messages for new (unknown) shards
are buffered until the new <code class="docutils literal"><span class="pre">ShardCoordinator</span></code> becomes available.</p>
<p>As long as a sender() uses the same <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor to deliver messages to an entry
actor the order of the messages is preserved. As long as the buffer limit is not reached
messages are delivered on a best effort basis, with at-most once delivery semantics,
in the same way as ordinary message sending. Reliable end-to-end messaging, with
at-least-once semantics can be added by using channels in <code class="docutils literal"><span class="pre">akka-persistence</span></code>.</p>
<p>Some additional latency is introduced for messages targeted to new or previously
unused shards due to the round-trip to the coordinator. Rebalancing of shards may
also add latency. This should be considered when designing the application specific
shard resolution, e.g. to avoid too fine grained shards.</p>
</div>
<div class="section" id="proxy-only-mode">
<h2>Proxy Only Mode</h2>
<p>The <code class="docutils literal"><span class="pre">ShardRegion</span></code> actor can also be started in proxy only mode, i.e. it will not
host any entries itself, but knows how to delegate messages to the right location.
A <code class="docutils literal"><span class="pre">ShardRegion</span></code> starts in proxy only mode if the roles of the node does not include
the node role specified in <code class="docutils literal"><span class="pre">akka.contrib.cluster.sharding.role</span></code> config property
or if the specified <cite>entryProps</cite> is <code class="docutils literal"><span class="pre">None</span></code> / <code class="docutils literal"><span class="pre">null</span></code>.</p>
</div>
<div class="section" id="passivation">
<h2>Passivation</h2>
<p>If the state of the entries are persistent you may stop entries that are not used to
reduce memory consumption. This is done by the application specific implementation of
the entry actors for example by defining receive timeout (<code class="docutils literal"><span class="pre">context.setReceiveTimeout</span></code>).
If a message is already enqueued to the entry when it stops itself the enqueued message
in the mailbox will be dropped. To support graceful passivation without loosing such
messages the entry actor can send <code class="docutils literal"><span class="pre">ShardRegion.Passivate</span></code> to its parent <code class="docutils literal"><span class="pre">ShardRegion</span></code>.
The specified wrapped message in <code class="docutils literal"><span class="pre">Passivate</span></code> will be sent back to the entry, which is
then supposed to stop itself. Incoming messages will be buffered by the <code class="docutils literal"><span class="pre">ShardRegion</span></code>
between reception of <code class="docutils literal"><span class="pre">Passivate</span></code> and termination of the entry. Such buffered messages
are thereafter delivered to a new incarnation of the entry.</p>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<p>The <code class="docutils literal"><span class="pre">ClusterSharding</span></code> extension can be configured with the following properties:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span># Settings for the ClusterShardingExtension
akka.contrib.cluster.sharding {
  # The extension creates a top level actor with this name in top level user scope,
  # e.g. &#39;/user/sharding&#39;
  guardian-name = sharding
  # If the coordinator can&#39;t store state changes it will be stopped
  # and started again after this duration.
  coordinator-failure-backoff = 10 s
  # Start the coordinator singleton manager on members tagged with this role.
  # All members are used if undefined or empty.
  # ShardRegion actor is started in proxy only mode on nodes that are not tagged
  # with this role.
  role = &quot;&quot;
  # The ShardRegion retries registration and shard location requests to the
  # ShardCoordinator with this interval if it does not reply.
  retry-interval = 2 s
  # Maximum number of messages that are buffered by a ShardRegion actor.
  buffer-size = 100000
  # Timeout of the shard rebalancing process.
  handoff-timeout = 60 s
  # Rebalance check is performed periodically with this interval.
  rebalance-interval = 10 s
  # How often the coordinator saves persistent snapshots, which are
  # used to reduce recovery times
  snapshot-interval = 3600 s
  # Setting for the default shard allocation strategy
  least-shard-allocation-strategy {
    # Threshold of how large the difference between most and least number of
    # allocated shards must be to begin the rebalancing.
    rebalance-threshold = 10
    # The number of ongoing rebalancing processes is limited to this number.
    max-simultaneous-rebalance = 3
  }
}
</pre></div>
</div>
<p>Custom shard allocation strategy can be defined in an optional parameter to
<code class="docutils literal"><span class="pre">ClusterSharding.start</span></code>. See the API documentation of <code class="docutils literal"><span class="pre">ShardAllocationStrategy</span></code>
(Scala) or <code class="docutils literal"><span class="pre">AbstractShardAllocationStrategy</span></code> (Java) for details of how to implement a custom
shard allocation strategy.</p>
</div>
</div>


          </div>
          <div class="span3"><p class="contents-title">Contents</p>
              <div id="scroller-anchor">
                <div id="scroller">
                  <div id="toc"></div>
                </div>
              </div></div>
        </div>
      </div>
    </div>
  </div>
  <div class="footer">
  <div class="container">
    <ul>
      <li><h5>Akka</h5></li>
      <li><a href="http://akka.io/docs">Documentation</a></li>
      <li><a href="http://akka.io/faq">FAQ</a></li>
      <li><a href="http://akka.io/downloads">Downloads</a></li>
      <li><a href="http://akka.io/news">News</a></li>
      <li><a href="http://letitcrash.com">Blog</a></li>
    </ul>
    <ul>
      <li><h5>Contribute</h5></li>
      <li><a href="http://akka.io/community">Community Projects</a></li>
      <li><a href="http://github.com/akka/akka">Source Code</a></li>
      <li><a href="http://groups.google.com/group/akka-user">Mailing List</a></li>      
      <li><a href="http://doc.akka.io/docs/akka/current/project/issue-tracking.html">Report a Bug</a></li>      
    </ul>
    <ul>
      <li><h5>Company</h5></li>
      <li><a href="http://www.typesafe.com/how/subscription">Commercial Support</a></li>
      <li><a href="http://akka.io/team">Team</a></li>
      <li><a href="mailto:info@typesafe.com">Contact</a></li>
    </ul>
    <ul>
      <li><img src="../_static/akka_icon_reverse.svg" align="center"/></li>
    </ul>
  </div>
  <div class="container copyright">
    <p style="float: left;">
      © 2014 <a href="http://www.typesafe.com/">Typesafe Inc.</a> <span class="license">Akka is Open Source and available under the Apache 2 License.</span>
    </p>
    <p style="float: right; font-size: 12px;">
      Last updated: Apr 01, 2016
    </p>          
  </div>
</div>
<script type="text/javascript">
  var $toc = $('#toc');
  $toc.toc();

  // change hash when TOC link clicked:
  $toc.find("a").click(function() { window.location.hash = $(this).attr('href'); });

  // show clickable section sign when section header hovered:
  $('.section h2,.section h3,.section h4,.section h5').each(function(i, el) {
      var $el = $(el);
      $el.prepend($("<a class='section-marker' href='#" + $el.attr("id") + "'>&sect;</a>"))
  });
</script>
  

  </body>
</html>